<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
    <title>DON'T STOP!</title>
    <link rel="icon" href="data:,">
    <link rel="stylesheet" href="../Style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Kosugi+Maru&display=swap" rel="stylesheet">
    <style>
      *{
        font-size: 0;
        display: inline-block;
        text-align: center;
      }
      @font-face
      {
        font-family: 'font-family: "Kosugi Maru", monospace, sans-serif';
        font-style: normal;
        font-weight: 100;
        src: url('mplus1p-thin.eot');  /* IE9+ */
        src: url('mplus1p-thin.eot?#iefix') format('embedded-opentype'),  /* IE8- */
             url('mplus1p-thin.woff') format('woff'),     /* その他のブラウザ */
             url('mplus1p-thin.ttf') format('truetype');  /* 古いiOS */
      }
      body{
        width : 100%;
        margin : 0;
        position : relative;
        display: inline-block;
      }
      #wrapper{
        position : absolute;
        display: inline-block;
        top : 0;
        left : 0;
        bottom : 0;
        right : 0;
        margin : auto;
        overflow: hidden;
      }
      .layer{
        position : absolute;
        display: inline-block;
        top : 0;
        left : 0;
        bottom : 0;
        right : 0;
        margin : auto;
        width : 100%;
        height : 100%;
        filter : drop-shadow(1px 1px 1px #222);
        /* レスポンシブ!!! */
        pointer-events: none;
      }
      .block_wrapper{
        display: inline-block;
        position: absolute;
        pointer-events: none;
      }
      canvas{
        width : 100%;
        height : 100%;
        position : absolute;
        left : 0;
        top : 0;
      }
      .joint{
        filter : drop-shadow(1px 1px 1px #222);
      }
    </style>
  </head>
  <body>
    <div id="wrapper">
    </div>
  </body>
  <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
  <script type="text/javascript">
    //



    /*定数変数メモ*\
    loop - ループしてよいか．緊急停止用．
    count - フレームのカウンタ．
    \*********/
    let Sleep = ms => new Promise(r=>setTimeout(r,ms));
    Math.mod = (x,m)=>(x%m+m)%m;//  勝手にmod関数を定義
    const wr = document.querySelector("#wrapper");
    const L=64,W=17,H=25,DT=1000;
    let colors = {
      white : "#ddd",
      gray : "#888",
      black : "#111",
      red : "#d00",
      pink : "#f6a",
      orange : "#f70",
      yellow : "#ee0",
      green : "#090",
      lime : "#5d4",
      cyan : "#0df",
      sky : "#58f",
      blue : "#21f",
      purple : "#82e",
      magenta : "#e09",
    };
    let count,loop,state,value,blocks,s,t,slider;

    //  フォントの読み込み後に開始
    WebFont.load({
      //custom : {
      custom : {
        families : ["Kosugi Maru"]
      },
      active : () => {
        Init();

        //  リサイズ時, canvasを画面の大きさに合わせる
        window.onresize = () => {Resize();}
        //  操作
        if(window.ontouchstart === null){
          //  タッチ操作
          wr.ontouchstart = (e) => {
            e.preventDefault();
            let l = Math.min(window.innerWidth/W,window.innerHeight/H)*.95;
            let x = (e.touches[0].clientX-wr.getBoundingClientRect().left)/l;//  wr左上からのcanvaspx値
            let y = (e.touches[0].clientY-wr.getBoundingClientRect().top)/l;

            //  スライダーの判定
            if(IsIn(x,y,slider.x,slider.y,slider.w,slider.h)){
              slider.down = 1;
            }
          }
          wr.ontouchmove = (e) => {
            e.preventDefault();
            let l = Math.min(window.innerWidth/W,window.innerHeight/H)*.95;
            let x = (e.touches[0].clientX-wr.getBoundingClientRect().left)/l;
            x = Math.min(Math.max(2.5,x),14.5);

            //  スライダー操作
            if(slider.down){
              t = (x-8.5)/6;
              slider.moveTo(x,slider.y);
            }
          }
          window.ontouchend = () => {
            slider.down = 0;
          }
        }
        else{
          //  マウス操作
          wr.onmousedown = (e) => {
            e.preventDefault();
            let l = Math.min(window.innerWidth/W,window.innerHeight/H)*.95;
            let x = e.offsetX/l;//  wr左上からのcanvaspx値
            let y = e.offsetY/l;

            //  スライダーの判定
            if(IsIn(x,y,slider.x,slider.y,slider.w,slider.h)){
              slider.down = 1;
            }
          }
          wr.onmousemove = (e) => {
            e.preventDefault();
            let l = Math.min(window.innerWidth/W,window.innerHeight/H)*.95;
            let x = e.offsetX/l;
            let y = e.offsetY/l;

            //  ポインタ
            if(IsIn(x,y,slider.x,slider.y,slider.w,slider.h)){
              document.body.style.cursor = "e-resize";
            }
            else{
              document.body.style.cursor = "default";
            }

            //  スライダー操作
            if(slider.down){
              document.body.style.cursor = "e-resize";
              x = Math.min(Math.max(2.5,x),14.5);
              s = (x-8.5)/6;
              slider.moveTo(x,slider.y);
            }
          }
          window.onmouseup = () => {
            slider.down = 0;
            document.body.style.cursor = "default";
          }
        }
      },
      inactive : () => {
        alert("フォント読み込み失敗");
      }
    });



    class Block{
      //  定義の例 : blocks.push(new Block(0,()=>t,1,1,3,0,"cyan"));
      constructor(...arg){
        const keys = ["x","y","z","w","h","angle","color","ornament"];//  最後の引数は数値であれば fixed, オブジェクトであれば ornament
        this.movable = 0;//  update時に動くかどうか
        for(let i=0; i<keys.length; i++){
          if(typeof arg[i] === "function"){
            Object.defineProperty(this,keys[i],{
              get : arg[i],
              writable : 1
            });
            this.movable = 1;
          }
          else{
            Object.defineProperty(this,keys[i],{
              value : arg[i],
              writable : 1
            });
          }
        }
        if(typeof this.ornament === "number"){
          this.fixed = this.ornament;
          this.ornament = undefined;
        }

        this.state = "preparing";
        this.isSlider = 0;
        this.f0 = count;
        if(Math.random()<.5){
          this.x0 = Math.random()<.5 ? -W/2 : W/2*3;
          this.y0 = Math.random()*H*2-H/5;
        }
        else{
          this.x0 = Math.random()*W*2-W/5;
          this.y0 = Math.random()<.5 ? -H/2 : H/2*3;
        }

        if(!document.querySelector("#layer-"+this.z)){
          let layer = document.createElement("div");
          layer.className = "layer";
          layer.id = "layer-"+this.z;
          wr.append(layer);
        }
        this.wr = document.createElement("div");
        this.wr.className = "block_wrapper";
        this.wr.style.width = `${(this.w)/W*100}%`;
        this.wr.style.height = `${(this.h)/H*100}%`;
        this.wr.style.left = `${(this.x0-this.w/2)/W*100}%`;
        this.wr.style.top = `${(this.y0-this.h/2)/H*100}%`;
        if(!this.fixed)this.wr.style.transition = `${DT}ms`;
        document.querySelector("#layer-"+this.z).append(this.wr);
        this.cvs0 = document.createElement("canvas");
        this.cvs0.width = L*this.w;
        this.cvs0.height = L*this.h;
        this.ctx0 = this.cvs0.getContext("2d");
        this.wr.append(this.cvs0);
        this.cvs1 = document.createElement("canvas");
        this.cvs1.className = "joint";
        this.cvs1.width = L*this.w;
        this.cvs1.height = L*this.h;
        this.ctx1 = this.cvs1.getContext("2d");
        this.wr.append(this.cvs1);

        this.render();
      }

      render(){
        //  下部
        this.ctx0.fillStyle = colors[this.color];
        this.ctx0.strokeStyle = "#333";
        this.ctx0.lineWidth = 3;
        this.ctx0.fillRect(0,0,L*this.w,L*this.h);
        this.ctx0.strokeRect(0,0,L*this.w,L*this.h);

        //  上部
        if(this.isSlider){
          this.ctx1.fillStyle = colors[this.color];
          this.ctx1.arc(0,0,L,0,Math.PI*2);
          this.ctx1.fill();
        }
        else{
          this.ctx1.fillStyle = colors[this.color];
          this.ctx1.beginPath();
          for(let j=0; j<this.h*2; j++){
            for(let i=0; i<this.w*2; i++){
              this.ctx1.moveTo(L/4*(i*2+1),L/4*(j*2+1));
              this.ctx1.arc(L/4*(i*2+1),L/4*(j*2+1),L/7,0,Math.PI*2);
            }
            this.ctx1.fill();
          }
        }
      }

      update(){
        let f = Math.mod(count-this.f0,3600);//  現在フレームの相対位置
        if(this.state === "ready"){
          this.state = "slidein";
          this.moveTo(this.x,this.y);
        }
        else if(this.state === "slidein"){
          if(!this.s || f/60*1000>DT){
            //  スライドイン終了
            this.state = "stable";
            this.wr.style.transition = `${0}ms`;
          }
        }
        else if(this.sate === "stable"){
          //  通常の更新
          if(this.movable){
            this.moveTo(this.x,this.y,this.angle);
          }
        }
        else if(this.state === "slideout"){
          if(f/60*1000>DT){
            //  スライドアウト終了
            blocks.splice(blocks.indexOf(this),1);
            this.wr.parentElement.removeChild(this.wr);
          }
        }
      }

      moveTo(x,y,a){
        this.wr.style.left = `${(x-this.w/2)/W*100}%`;
        this.wr.style.top = `${(y-this.h/2)/H*100}%`;
        this.wr.style.transform = `rotate(${a}rad)`;
        if(typeof this.x !== "function")this.x = x;
        if(typeof this.y !== "function")this.y = y;
        if(typeof this.angle !== "function")this.angle = a;
      }

      slideout(){
        this.state = "slideout";
        this.x = this.x0;
        this.y = this.y0;
      }
    }



    function Resize(){
      let len = Math.min(window.innerWidth/W,window.innerHeight/H)*.95;
      document.body.style.height = `${window.innerHeight}px`;
      wr.style.width = `${len*W}px`;
      wr.style.height = `${len*H}px`;
    }

    async function Init(){
      blocks = []
      blocks.state = "";
      blocks.reset = ()=>{
        //  消去
        wr.innerHTML = "";
        //  リセット
        blocks.splice(0,blocks.length);
        //  背景
        blocks.push(new Block(W/2,H/2,0,W,H,0,"gray",1));
        //  枠
        blocks.push(new Block(W/2,.5,1,W,1,0,"white",1));
        blocks.push(new Block(W/2,H-.5,1,W,1,0,"white",1));
        blocks.push(new Block(.5,H/2,1,1,H-2,0,"white",1));
        blocks.push(new Block(W-.5,H/2,1,1,H-2,0,"white",1));
        blocks.push(new Block(W/2,H-3.5,1,W-2,1,0,"white",1));

        slider = new Block(W/2,H-2,1,3,2,0,"white");
        slider.isSlider = 1;
        blocks.push(slider);
      };

      t = 0;
      count = 0;
      state = "title";
      Resize();
      if(loop){
        loop = 0;
        await Sleep(1000/20);
      }
      loop = 1;
      Update();
      Main();
    }

    //  ループ, フレームの制御
    async function Main(){
      if(!loop)return 0;
      Update();
      await Sleep(1000/60);
      count = (count+1)%3600;
      Main();
    }

    async function Update(){
      if(state !== blocks.state){
        //ブロックの設定
        if(state === "title"){
          blocks.state = "title";

          //  ブロック定義
          blocks.reset();
          blocks.push(new Block(W/2-6,3.5,1,1,3,0,"cyan"));
          blocks.push(new Block(W/2-4,3.5,1,1,2,0,"cyan"));
          blocks.push(new Block(W/2-5,2.5,1,1,1,0,"cyan"));
          blocks.push(new Block(W/2-5,4.5,1,1,1,0,"cyan"));
          blocks.push(new Block(W/2-4.25,2.25,1,.5,.5,0,"cyan"));
          blocks.push(new Block(W/2-4.25,4.75,1,.5,.5,0,"cyan"));
          blocks.push(new Block(W/2-3,3.75,1,1,1.5,0,"orange"));
          blocks.push(new Block(W/2-1,3.25,1,1,1.5,0,"orange"));
          blocks.push(new Block(W/2-2.25,2.5,1,1.5,1,0,"orange"));
          blocks.push(new Block(W/2-1.75,4.5,1,1.5,1,0,"orange"));
          blocks.push(new Block(W/2-1.25,2.25,1,.5,.5,0,"orange"));
          blocks.push(new Block(W/2-2.75,4.75,1,.5,.5,0,"orange"));
          blocks.push(new Block(W/2-.75,4.25,1,.5,.5,0,"orange"));
          blocks.push(new Block(W/2-3.25,2.75,1,.5,.5,0,"orange"));
          blocks.push(new Block(W/2,3.5,1,1,3,0,"lime"));
          blocks.push(new Block(W/2+2,3.5,1,1,3,0,"lime"));
          blocks.push(new Block(W/2+.75,3.25,1,.5,1.5,0,"lime"));
          blocks.push(new Block(W/2+1.25,3.75,1,.5,1.5,0,"lime"));
          blocks.push(new Block(W/2+3,2.75,1,1,1.5,0,"yellow"));
          blocks.push(new Block(W/2+5,2.5,1,3,1,0,"purple"));
          blocks.push(new Block(W/2+5,4,1,1,2,0,"purple"));

          blocks.push(new Block(W/2-5.5,7,1,1,2,0,"red"));
          blocks.push(new Block(W/2-4.5,8,1,1,2,0,"red"));
          blocks.push(new Block(W/2-6.25,7,1,.5,1,0,"red"));
          blocks.push(new Block(W/2-3.75,8,1,.5,1,0,"red"));
          blocks.push(new Block(W/2-4.25,6.25,1,1.5,.5,0,"red"));
          blocks.push(new Block(W/2-5.75,8.75,1,1.5,.5,0,"red"));
          blocks.push(new Block(W/2-2,6.5,1,3,1,0,"blue"));
          blocks.push(new Block(W/2-2,8,1,1,2,0,"blue"));
          blocks.push(new Block(W/2,7.75,1,1,1.5,0,"pink"));
          blocks.push(new Block(W/2+2,7.25,1,1,1.5,0,"pink"));
          blocks.push(new Block(W/2+.75,6.5,1,1.5,1,0,"pink"));
          blocks.push(new Block(W/2+1.25,8.5,1,1.5,1,0,"pink"));
          blocks.push(new Block(W/2+1.75,6.25,1,.5,.5,0,"pink"));
          blocks.push(new Block(W/2+.25,8.75,1,.5,.5,0,"pink"));
          blocks.push(new Block(W/2+2.25,8.25,1,.5,.5,0,"pink"));
          blocks.push(new Block(W/2-.25,6.75,1,.5,.5,0,"pink"));
          blocks.push(new Block(W/2+3,7.5,1,1,3,0,"green"));
          blocks.push(new Block(W/2+5,7.25,1,1,1.5,0,"green"));
          blocks.push(new Block(W/2+4,6.5,1,1,1,0,"green"));
          blocks.push(new Block(W/2+4,8,1,1,1,0,"green"));
          blocks.push(new Block(W/2+4.75,6.25,1,.5,.5,0,"green"));
          blocks.push(new Block(W/2+4.75,8.25,1,.5,.5,0,"green"));
          blocks.push(new Block(W/2+6,7,1,1,2,0,"sky"));
          blocks.push(new Block(W/2+6,8.75,1,1,.5,0,"sky"));
        }
        await Sleep(10);
        blocks.forEach((v,i) => {
          v.update();
          v.state = "ready";
        });
      }
      else{
        //  通常の更新
        blocks.forEach((v,i) => {
          v.update();
        });
      }
    }

    //  矩形内にあるか
    function IsIn(x,y,x0,y0,w,h){
      let bool = 1;
      bool = bool && x0-w/2 < x;
      bool = bool && x < x0+w/2;
      bool = bool && y0-h/2 < y;
      bool = bool && y < y0+h/2;
      return bool;
    }
















  </script>
</html>
