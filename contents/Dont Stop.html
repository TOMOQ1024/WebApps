<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
    <title>DON'T STOP!</title>
    <link rel="icon" href="data:,">
    <link rel="stylesheet" href="../Style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Kosugi+Maru&display=swap" rel="stylesheet">
    <style>
      *{
        font-size: 0;
        display: inline-block;
        text-align: center;
      }
      @font-face
      {
        font-family: 'font-family: "Kosugi Maru", monospace, sans-serif';
        font-style: normal;
        font-weight: 100;
        src: url('mplus1p-thin.eot');  /* IE9+ */
        src: url('mplus1p-thin.eot?#iefix') format('embedded-opentype'),  /* IE8- */
             url('mplus1p-thin.woff') format('woff'),     /* その他のブラウザ */
             url('mplus1p-thin.ttf') format('truetype');  /* 古いiOS */
      }
      body{
        width : 100%;
        margin : 0;
        position : relative;
        display: inline-block;
      }
      #wrapper{
        position : absolute;
        display: inline-block;
        top : 0;
        left : 0;
        bottom : 0;
        right : 0;
        margin : auto;
        overflow: hidden;
      }
      canvas{
        filter : drop-shadow(1px 1px 1px #222);
        width : 100%;
        height : 100%;
        position : absolute;
        left : 0;
        top : 0;
      }
    </style>
  </head>
  <body>
    <div id="wrapper">
    </div>
  </body>
  <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
  <script type="text/javascript">
    //



    /*定数変数メモ*\
    loop - ループしてよいか．緊急停止用．
    count - フレームのカウンタ．
    \*********/
    let Sleep = ms => new Promise(r=>setTimeout(r,ms));
    Math.mod = (x,m)=>(x%m+m)%m;//  勝手にmod関数を定義
    const wr = document.querySelector("#wrapper");
    const L=64,W=17,H=25,DT=1000;
    let colors = {
      white : "#ddd",
      gray : "#888",
      black : "#111",
      red : "#d00",
      pink : "#f6a",
      orange : "#f70",
      yellow : "#ee0",
      green : "#090",
      lime : "#5d4",
      cyan : "#0df",
      sky : "#58f",
      blue : "#21f",
      purple : "#82e",
      magenta : "#e09",
    };
    let count,loop,state,value,blocks,t;

    //  フォントの読み込み後に開始
    WebFont.load({
      //custom : {
      custom : {
        families : ["Kosugi Maru"]
      },
      active : () => {
        Init();

        //  リサイズ時, canvasを画面の大きさに合わせる
        window.onresize = () => {Resize();}
        //  操作
      },
      inactive : () => {
        alert("フォント読み込み失敗");
      }
    });



    class Block{
      //  定義の例 : blocks.push(new Block(0,()=>t,1,1,3,0,"cyan"));
      constructor(...arg){
        const keys = "xyzwhacs";
        for(let i=0; i<keys.length; i++){
          if(typeof arg[i] === "function"){
            Object.defineProperty(this,keys[i],{
              get : arg[i],
              writable : 1
            });
          }
          else{
            Object.defineProperty(this,keys[i],{
              value : arg[i],
              writable : 1
            });
          }
        }
        this.state = "preparing";
        this.f0 = count;
        if(Math.random()<.5){
          this.x0 = Math.random()<.5 ? -W/2 : W/2*3;
          this.y0 = Math.random()*H*2-H/5;
        }
        else{
          this.x0 = Math.random()*W*2-W/5;
          this.y0 = Math.random()<.5 ? -H/2 : H/2*3;
        }

        this.wr = document.createElement("div");
        this.wr.style.display = "inline-box";
        this.wr.style.position = "absolute";
        this.wr.style.width = `${(this.w)/W*100}%`;
        this.wr.style.height = `${(this.h)/H*100}%`;
        this.wr.style.left = `${(this.x0-this.w/2)/W*100}%`;
        this.wr.style.top = `${(this.y0-this.h/2)/H*100}%`;
        this.wr.style.transition = `${DT}ms`;
        wr.append(this.wr);
        this.cvs0 = document.createElement("canvas");
        this.cvs0.width = L*this.w;
        this.cvs0.height = L*this.h;
        this.ctx0 = this.cvs0.getContext("2d");
        this.wr.append(this.cvs0);
        this.cvs1 = document.createElement("canvas");
        this.cvs1.width = L*this.w;
        this.cvs1.height = L*this.h;
        this.ctx1 = this.cvs1.getContext("2d");
        this.wr.append(this.cvs1);

        this.render();
      }

      render(){
        //  下部
        this.ctx0.fillStyle = colors[this.c];
        this.ctx0.strokeStyle = "#333";
        this.ctx0.lineWidth = 3;
        this.ctx0.fillRect(0,0,L*this.w,L*this.h);
        this.ctx0.strokeRect(0,0,L*this.w,L*this.h);

        //  上部
        this.ctx1.fillStyle = colors[this.c];
        this.ctx1.beginPath();
        for(let j=0; j<this.h*2; j++){
          for(let i=0; i<this.w*2; i++){
            this.ctx1.moveTo(L/4*(i*2+1),L/4*(j*2+1));
            this.ctx1.arc(L/4*(i*2+1),L/4*(j*2+1),L/7,0,Math.PI*2);
          }
          this.ctx1.fill();
        }
      }

      update(){
        let f = Math.mod(count-this.f0,3600);//  現在フレームの相対位置
        if(this.state === "ready"){
          this.state = "slidein";
          this.wr.style.left = `${(this.x-this.w/2)/W*100}%`;
          this.wr.style.top = `${(this.y-this.h/2)/H*100}%`;
        }
        else if(this.state === "slidein"){
          if(f/60*1000>DT){
            //  スライドイン終了
            this.x = Smooth(f/60*2,this.x0,this.x1);
            this.y = Smooth(f/60*2,this.y0,this.y1);
          }
          else{
            this.x = this.x1;
            this.y = this.y1;
            this.state = "stable";
          }
        }
      }
    }



    function Resize(){
      let len = Math.min(window.innerWidth/W,window.innerHeight/H)*.95;
      document.body.style.height = `${window.innerHeight}px`;
      wr.style.width = `${len*W}px`;
      wr.style.height = `${len*H}px`;
    }

    async function Init(){
      blocks = []
      blocks.state = "";
      blocks.reset = ()=>{
        blocks.splice(0,blocks.length);
        //  背景
        blocks.push(new Block(W/2,H/2,0,W,H,0,"gray"));
        //  枠
        blocks.push(new Block(W/2,.5,1,W,1,0,"white"));
        blocks.push(new Block(W/2,H-.5,1,W,1,0,"white"));
        blocks.push(new Block(.5,H/2,1,1,H-2,0,"white"));
        blocks.push(new Block(W-.5,H/2,1,1,H-2,0,"white"));
        blocks.push(new Block(W/2,H-3.5,1,W-2,1,0,"white"));

        blocks.push(new Block(W/2,H-2,1,3,2,0,"white","|||"));
      };
      blocks.sort = () => {
        //  ブロックのソート!!!
      }
      t = 0;
      count = 0;
      state = "title";
      Resize();
      if(loop){
        loop = 0;
        await Sleep(1000/20);
      }
      loop = 1;
      Update();
      Main();
    }

    //  ループ, フレームの制御
    async function Main(){
      if(!loop)return 0;
      Update();
      await Sleep(1000/60);
      count = (count+1)%3600;
      Main();
    }

    async function Update(){
      if(state !== blocks.state){
        //ブロックの設定
        if(state === "title"){
          blocks.state = "title";

          //  ブロック定義
          blocks.reset();
          blocks.push(new Block(W/2-6,3.5,1,1,3,0,"cyan"));
          blocks.push(new Block(W/2-4,3.5,1,1,2,0,"cyan"));
          blocks.push(new Block(W/2-5,2.5,1,1,1,0,"cyan"));
          blocks.push(new Block(W/2-5,4.5,1,1,1,0,"cyan"));
          blocks.push(new Block(W/2-4.25,2.25,1,.5,.5,0,"cyan"));
          blocks.push(new Block(W/2-4.25,4.75,1,.5,.5,0,"cyan"));
          blocks.push(new Block(W/2-3,3.75,1,1,1.5,0,"orange"));
          blocks.push(new Block(W/2-1,3.25,1,1,1.5,0,"orange"));
          blocks.push(new Block(W/2-2.25,2.5,1,1.5,1,0,"orange"));
          blocks.push(new Block(W/2-1.75,4.5,1,1.5,1,0,"orange"));
          blocks.push(new Block(W/2-1.25,2.25,1,.5,.5,0,"orange"));
          blocks.push(new Block(W/2-2.75,4.75,1,.5,.5,0,"orange"));
          blocks.push(new Block(W/2-.75,4.25,1,.5,.5,0,"orange"));
          blocks.push(new Block(W/2-3.25,2.75,1,.5,.5,0,"orange"));
          blocks.push(new Block(W/2,3.5,1,1,3,0,"lime"));
          blocks.push(new Block(W/2+2,3.5,1,1,3,0,"lime"));
          blocks.push(new Block(W/2+.75,3.25,1,.5,1.5,0,"lime"));
          blocks.push(new Block(W/2+1.25,3.75,1,.5,1.5,0,"lime"));
          blocks.push(new Block(W/2+3,2.75,1,1,1.5,0,"yellow"));
          blocks.push(new Block(W/2+5,2.5,1,3,1,0,"purple"));
          blocks.push(new Block(W/2+5,4,1,1,2,0,"purple"));

          blocks.push(new Block(W/2-5.5,7,1,1,2,0,"red"));
          blocks.push(new Block(W/2-4.5,8,1,1,2,0,"red"));
          blocks.push(new Block(W/2-6.25,7,1,.5,1,0,"red"));
          blocks.push(new Block(W/2-3.75,8,1,.5,1,0,"red"));
          blocks.push(new Block(W/2-4.25,6.25,1,1.5,.5,0,"red"));
          blocks.push(new Block(W/2-5.75,8.75,1,1.5,.5,0,"red"));
          blocks.push(new Block(W/2-2,6.5,1,3,1,0,"blue"));
          blocks.push(new Block(W/2-2,8,1,1,2,0,"blue"));
          blocks.push(new Block(W/2,7.75,1,1,1.5,0,"pink"));
          blocks.push(new Block(W/2+2,7.25,1,1,1.5,0,"pink"));
          blocks.push(new Block(W/2+.75,6.5,1,1.5,1,0,"pink"));
          blocks.push(new Block(W/2+1.25,8.5,1,1.5,1,0,"pink"));
          blocks.push(new Block(W/2+1.75,6.25,1,.5,.5,0,"pink"));
          blocks.push(new Block(W/2+.25,8.75,1,.5,.5,0,"pink"));
          blocks.push(new Block(W/2+2.25,8.25,1,.5,.5,0,"pink"));
          blocks.push(new Block(W/2-.25,6.75,1,.5,.5,0,"pink"));
          blocks.push(new Block(W/2+3,7.5,1,1,3,0,"green"));
          blocks.push(new Block(W/2+5,7.25,1,1,1.5,0,"green"));
          blocks.push(new Block(W/2+4,6.5,1,1,1,0,"green"));
          blocks.push(new Block(W/2+4,8,1,1,1,0,"green"));
          blocks.push(new Block(W/2+4.75,6.25,1,.5,.5,0,"green"));
          blocks.push(new Block(W/2+4.75,8.25,1,.5,.5,0,"green"));
          blocks.push(new Block(W/2+6,7,1,1,2,0,"sky"));
          blocks.push(new Block(W/2+6,8.75,1,1,.5,0,"sky"));
        }
      }
      await Sleep(10);
      blocks.forEach((v,i) => {
        v.update();
        v.state = "ready";
      });
    }

    //  x,yを中心とした幅w,hのaだけ傾いたブロックをレイヤーzに色cで描画する
    //  c未入力でクリア

    /*
    function DrawBlock(block){
      //
    }
    */

    //  滑らかにつなぐ関数
    /*
    function Smooth(x,y0,y1){
      return (y1-y0)*(1-Math.cos(Math.PI*x))/2+y0;
    }
    */
















  </script>
</html>
