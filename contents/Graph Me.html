<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
    <title>Graph Me</title>
    <link rel="icon" href="data:,">
    <link rel="stylesheet" href="../Style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap" rel="stylesheet">
    <style>
      *{
        font-size: 0;
        display: inline-block;
        text-align: center;
      }
      @font-face
      {
        font-family: 'Roboto Mono, monospace';
        font-style: normal;
        font-weight: 100;
        src: url('mplus1p-thin.eot');  /* IE9+ */
        src: url('mplus1p-thin.eot?#iefix') format('embedded-opentype'),  /* IE8- */
             url('mplus1p-thin.woff') format('woff'),     /* その他のブラウザ */
             url('mplus1p-thin.ttf') format('truetype');  /* 古いiOS */
      }
      body{
        width : 100%;
        margin : 0;
      }
      #wrapper{
        position : relative;
        overflow: visible;
        display: inline-block;
        width : 100%;
      }
      canvas{
        position : absolute;
        top : 0;
        left : 0;
        bottom : 0;
        right : 0;
        margin : auto;
      }
    </style>
  </head>
  <body>
    <div id="wrapper">
      <canvas id="background_canvas" width="1000" height="1650"></canvas>
      <canvas id="main_canvas" width="1000" height="1650"></canvas>
    </div>
  </body>
  <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
  <script type="text/javascript">
    //


    /*
    参考資料等

    使用フォント:Roboto Mono(Google fonts)
    https://fonts.google.com/specimen/Roboto+Mono?category=Monospace

    フォントのロードの検知:Web Font Loader
    参考:http://ithat.me/2016/12/10/js-web-font-load-start-complete-detection-web-font-loader

    音源(不具合により全て削除済み．)
    ・フリー効果音素材 くらげ工匠 : http://www.kurage-kosho.info/
      =>ボタン押下 - button68.mp3
      =>スライダー移動 - button45.mp3
    ・効果音ラボ : https://soundeffect-lab.info/
      =>クリア - データ解析.mp3
    */


    let Sleep = ms => new Promise(r=>setTimeout(r,ms));
    Math.mod = (x,m)=>(x%m+m)%m;//  勝手にmod関数を定義
    let bvs,btx,cvs,ctx,touches,buttons,vars,graph,ctrl,level,clear,colors,cdata,cdata0,save;

    //  式が一致しているかの確認!!!
    let problems0 = {
       0 : {
         type : "title",
         xaxis : 370,//  0...740
         yaxis : 460,//  0...920
         gscale : 175/2,//  グラフの目盛
         vars : [0,0,1,0],//  各変数を使用するかどうか
         min : [-1,-1,0,-1],//  最小値
         value : [0,0,.6,0],//  初期値
         max : [1,1,1,1],//  最大値  いつか2にする!!!
         vscale : [0,0,0,0],//  変数値の目盛
         answer : [0,0,0,0]//  各変数の解答値
       },
       145 : {
         type : "congrats",
         xaxis : 370,//  0...740
         yaxis : 460,//  0...920
         gscale : 175/2,//  グラフの目盛
         vars : [0,0,1,0],//  各変数を使用するかどうか
         min : [-1,-1,0,-1],//  最小値
         value : [0,0,2,0],//  初期値
         max : [1,1,2,1],//  最大値  いつか2にする!!!
         vscale : [0,0,0,0],//  変数値の目盛
         answer : [0,0,-1,0]//  各変数の解答値
       },
    }
    let problems1 = {
      1  : {
        type : "explicit",
        funcstr : "y=a",
        func : (x,a,b,c,d) => {
          return a;
        },
        xaxis : 550,
        yaxis : 460,
        gscale : 60,
        vars : [1,0,0,0],
        min : [-6,-1,-1,-1],
        value : [0,0,0,0],
        max : [6,1,1,1],
        vscale : [0,0,0,0],
        answer : [4,0,0,0]
      },
      2  : {
        type : "explicit",
        funcstr : "y=ax+b",
        func : (x,a,b,c,d) => {
          return a*x+b;
        },
        xaxis : 550,
        yaxis : 460,
        gscale : 60,
        vars : [1,1,0,0],
        min : [-6,-6,-1,-1],
        value : [0,0,0,0],
        max : [6,6,1,1],
        vscale : [0,0,0,0],
        answer : [3,-2,0,0]
      },
      3  : {
        type : "explicit",
        funcstr : "y=a+b(x-2)",
        func : (x,a,b,c,d) => {
          return a+b*(x-2);
        },
        xaxis : 550,
        yaxis : 320,
        gscale : 60,
        vars : [1,1,0,0],
        min : [-6,-3,-1,-1],
        value : [0,0,0,0],
        max : [6,3,1,1],
        vscale : [0,0,0,0],
        answer : [2,.5,0,0]
      },
      4  : {
        type : "explicit",
        funcstr : "y=a(bx+1)",
        func : (x,a,b,c,d) => {
          return a*(b*x+1);
        },
        xaxis : 200,
        yaxis : 460,
        gscale : 60,
        vars : [1,1,0,0],
        min : [-9,-1,-1,-1],
        value : [-3,0,0,0],
        max : [3,1,1,1],
        vscale : [0,0,0,0],
        answer : [-6,.25,0,0]
      },
      5  : {
        type : "explicit",
        funcstr : "y=ax^2+b",
        func : (x,a,b,c,d) => {
          return a*x*x+b;
        },
        xaxis : 370,
        yaxis : 460,
        gscale : 60,
        vars : [1,1,0,0],
        min : [-1,-5,-1,-1],
        value : [0,0,0,0],
        max : [1,5,1,1],
        vscale : [0,0,0,0],
        answer : [-.25,3,0,0]
      },
      6  : {
        type : "explicit",
        funcstr : "y=a(x-b)^2+c",
        func : (x,a,b,c,d) => {
          return a*(x-b)**2+c;
        },
        xaxis : 370,
        yaxis : 460,
        gscale : 60,
        vars : [1,1,1,0],
        min : [-3,-6,-6,-1],
        value : [0,0,0,0],
        max : [3,6,6,1],
        vscale : [0,0,0,0],
        answer : [.5,3,-2,0]
      },
      7  : {
        type : "explicit",
        funcstr : "y=a(x-b)(x-c)",
        func : (x,a,b,c,d) => {
          return a*(x-b)*(x-c);
        },
        xaxis : 370,
        yaxis : 460,
        gscale : 60,
        vars : [1,1,1,0],
        min : [-1,-5,-10,-1],
        value : [0,0,0,0],
        max : [1,5,10,1],
        vscale : [0,0,0,0],
        answer : [.125,3,-6,0]
      },
      8  : {
        type : "explicit",
        funcstr : "y=ax(x-b)+c",
        func : (x,a,b,c,d) => {
          return a*x*(x-b)+c;
        },
        xaxis : 370,
        yaxis : 460,
        gscale : 60,
        vars : [1,1,1,0],
        min : [-1,-10,-10,-1],
        value : [0,0,0,0],
        max : [1,10,10,1],
        vscale : [0,0,0,0],
        answer : [-.25,4,3,0]
      },
      9  : {
        type : "explicit",
        hide : 1,
        tangent : 1,
        funcstr : "y=F{1}{4}x^2+a",
        func : (x,a,b,c,d) => {
          return x*x/4+a;
        },
        funcTangent : (x,a,b,c,d)=>{
          return x-5;
        },
        xaxis : 370,
        yaxis : 460,
        gscale : 60,
        vars : [1,0,0,0],
        min : [-10,-10,-10,-1],
        value : [0,0,0,0],
        max : [10,10,10,1],
        vscale : [0,0,0,0],
        answer : [-4,4,3,0]
      },
      10 : {
        type : "explicit",
        hide : 1,
        points : [4],
        tangent : 1,
        funcstr : "y=ax^2+abx",
        func : (x,a,b,c,d) => {
          return a*x*x+a*b*x;
        },
        funcTangent : (x,a,b,c,d)=>{
          return x-4;
        },
        xaxis : 500,
        yaxis : 300,
        gscale : 60,
        vars : [1,1,0,0],
        min : [-1,-5,-10,-1],
        value : [0,0,0,0],
        max : [1,5,10,1],
        vscale : [0,0,0,0],
        answer : [.25,-4,3,0]
      },
      11 : {
        type : "explicit",
        hide : 1,
        points : [0,4],
        tangent : 1,
        funcstr : "y=a(x^2-b)",
        func : (x,a,b,c,d) => {
          return a*(x*x-b);
        },
        funcTangent : (x,a,b,c,d)=>{
          return -5;
        },
        xaxis : 400,
        yaxis : 400,
        gscale : 60,
        vars : [1,1,0,0],
        min : [-1,-2,-10,-1],
        value : [0,4,0,0],
        max : [1,10,10,1],
        vscale : [0,0,0,0],
        answer : [.5,10,3,0]
      },
      12 : {
        type : "explicit",
        hide : 1,
        points : [-3,1,5],
        tangent : 0,
        funcstr : "y=F{x^2}{a}+F{x}{b}+c",
        func : (x,a,b,c,d) => {
          return x*x/a+x/b+c;
        },
        funcTangent : (x,a,b,c,d)=>{
          return -5;
        },
        xaxis : 400,
        yaxis : 400,
        gscale : 60,
        vars : [1,1,1,0],
        min : [-5,-2,-5,-1],
        value : [0,0,0,0],
        max : [5,2,5,1],
        vscale : [0,0,0,0],
        answer : [4,-2,-3.75,0]
      },
    };
    let problems2 = {
      13 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        funcstr : "y=asin(x)+b",
        func : (x,a,b,c,d) => {
          return a*Math.sin(x)+b;
        },
        funcTangent : (x,a,b,c,d)=>{
          return -5;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,0,0],
        min : [-5,-5,-5,-1],
        value : [0,0,0,0],
        max : [5,5,5,1],
        vscale : [0,0,0,0],
        answer : [3,-2,-3.75,0]
      },
      14 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        funcstr : "y=acos(bx)+c",
        func : (x,a,b,c,d) => {
          return a*Math.cos(b*x)+c;
        },
        funcTangent : (x,a,b,c,d)=>{
          return -5;
        },
        xaxis : 450,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,0],
        min : [-5,0,-5,-1],
        value : [0,2.5,0,0],
        max : [5,5,5,1],
        vscale : [0,0,0,0],
        answer : [2,5,1,0]
      },
      15 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        funcstr : "y=atan(bx)+c",
        func : (x,a,b,c,d) => {
          return a*Math.tan(b*x)+c;
        },
        funcTangent : (x,a,b,c,d)=>{
          return -5;
        },
        xaxis : 500,//370
        yaxis : 460,//460
        gscale : 61,
        vars : [1,1,1,0],
        min : [-2,0,-5,-1],
        value : [0,1.5,0,0],
        max : [2,3,5,1],
        vscale : [0,0,0,0],
        answer : [-1,.5,3,0]
      },
      16 : {
        type : "explicit",
        hide : 1,
        points : [0],
        tangent : 1,
        funcstr : "y=asin(x-b)",
        func : (x,a,b,c,d) => {
          return a*Math.sin(x-b);
        },
        funcTangent : (x,a,b,c,d)=>{
          return -3;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,0,0],
        min : [0,-2,-5,-1],
        value : [2.5,0,0,0],
        max : [5,2,5,1],
        vscale : [0,0,0,0],
        answer : [3,-1,3,0]
      },
      17 : {
        type : "explicit",
        hide : 1,
        points : [0],
        tangent : 1,
        tangent2 : 1,
        funcstr : "y=asin(x-b)+c",
        func : (x,a,b,c,d) => {
          return a*Math.sin(x-b)+c;
        },
        funcTangent : (x,a,b,c,d)=>{
          return -1;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -7;
        },
        xaxis : 100,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,0],
        min : [0,0,-5,-1],
        value : [2.5,2.5,0,0],
        max : [5,5,5,1],
        vscale : [0,0,0,0],
        answer : [3,4,-4,0]
      },
      18 : {
        type : "explicit",
        hide : 1,
        points : [5],
        tangent : 1,
        tangent2 : 1,
        funcstr : "y=axsin(2x-b)",
        func : (x,a,b,c,d) => {
          return a*x*Math.sin(2*x-b);
        },
        funcTangent : (x,a,b,c,d)=>{
          return x/2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -x/2;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,0,0],
        min : [0,-2,-5,-1],
        value : [1,0,0,0],
        max : [2,2,5,1],
        vscale : [0,0,0,0],
        answer : [.5,2,-4,0]
      },
      19 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=acos(bx-c)+d",
        func : (x,a,b,c,d) => {
          return a*Math.cos(b*x-c)+d;
        },
        funcTangent : (x,a,b,c,d)=>{
          return x/2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -x/2;
        },
        xaxis : 500,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,1],
        min : [-5,0,-1,-5],
        value : [0,2.5,0,0],
        max : [5,5,1,5],
        vscale : [0,0,0,0],
        answer : [-3,3,1,3]
      },
      20 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=asinbx+cx",
        func : (x,a,b,c,d) => {
          return a*Math.sin(b*x)+c*x;
        },
        funcTangent : (x,a,b,c,d)=>{
          return x/2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -x/2;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,0],
        min : [0,-10,-3,-1],
        value : [2.5,0,0,0],
        max : [5,10,3,1],
        vscale : [0,0,0,0],
        answer : [4,-5,.75,0]
      },
      21 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=asinbx+tancx",
        func : (x,a,b,c,d) => {
          return a*Math.sin(b*x)+Math.tan(c*x);
        },
        funcTangent : (x,a,b,c,d)=>{
          return x/2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -x/2;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,0],
        min : [0,-9,-3,-1],
        value : [2.5,0,0,0],
        max : [5,9,3,1],
        vscale : [0,.5,0,0],
        answer : [2,7,1,0]
      },
      22 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=2sinax+sinbx",
        func : (x,a,b,c,d) => {
          return 2*Math.sin(a*x)+Math.sin(b*x);
        },
        funcTangent : (x,a,b,c,d)=>{
          return x/2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -x/2;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 80,
        vars : [1,1,0,0],
        min : [0,0,-5,-1],
        value : [2.5,5,0,0],
        max : [5,10,5,1],
        vscale : [0,0,0,0],
        answer : [2,10,-4,0]
      },
      23 : {
        type : "explicit",
        hide : 1,
        points : [],
        tangent : 1,
        tangent2 : 1,
        funcstr : "y=(ax-b)cos3x+c",
        func : (x,a,b,c,d) => {
          return (a*x-b)*Math.cos(3*x)+c;
        },
        funcTangent : (x,a,b,c,d)=>{
          return x-3;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return 7-x;
        },
        xaxis : 500,//370
        yaxis : 300,//460
        gscale : 60,
        vars : [1,1,1,0],
        min : [-3,-4,-3,-5],
        value : [0,1,0,0],
        max : [3,6,3,5],
        vscale : [0,0,0,0],
        answer : [1,5,2,3]
      },
      24 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=asinbxsincx",
        func : (x,a,b,c,d) => {
          return a*Math.sin(b*x)*Math.sin(c*x);
        },
        funcTangent : (x,a,b,c,d)=>{
          return x-3;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return 7-x;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 80,
        vars : [1,1,1,0],
        min : [0,0,0,-5],
        value : [2.5,2.5,5,0],
        max : [5,5,10,5],
        vscale : [0,0,0,0],
        answer : [3,3,8,3]
      },
    };
    let problems3 = {
      25 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=a|x-b|+c",
        func : (x,a,b,c,d) => {
          return a*Math.abs(x-b)+c;
        },
        funcTangent : (x,a,b,c,d)=>{
          return x-3;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return 7-x;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,0],
        min : [-5,-5,-5,-5],
        value : [0,0,0,0],
        max : [5,5,5,5],
        vscale : [0,0,0,0],
        answer : [2,3,-3,3]
      },
      26 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=a#||x-b|-c#|-d",
        func : (x,a,b,c,d) => {
          return a*Math.abs(Math.abs(x-b)-c)-d;
        },
        funcTangent : (x,a,b,c,d)=>{
          return x-3;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return 7-x;
        },
        xaxis : 370,//370
        yaxis : 300,//460
        gscale : 60,
        vars : [1,1,1,1],
        min : [-5,-5,-5,-5],
        value : [0,0,0,0],
        max : [5,5,5,5],
        vscale : [0,0,0,0],
        answer : [2,3,2,3]
      },
      27 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=a#||x-b|-c#|+x-d",
        func : (x,a,b,c,d) => {
          return a*Math.abs(Math.abs(x-b)-c)+x-d;
        },
        funcTangent : (x,a,b,c,d)=>{
          return x-3;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return 7-x;
        },
        xaxis : 370,//370
        yaxis : 300,//460
        gscale : 60,
        vars : [1,1,1,1],
        min : [-2,-5,-5,-5],
        value : [0,0,0,0],
        max : [2,5,5,5],
        vscale : [0,0,0,0],
        answer : [1,4,1,5]
      },
      28 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=a|x^2+bx|+cx",
        func : (x,a,b,c,d) => {
          return a*Math.abs(x*x+b*x)+c*x;
        },
        funcTangent : (x,a,b,c,d)=>{
          return x-3;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return 7-x;
        },
        xaxis : 600,//370
        yaxis : 560,//460
        gscale : 80,
        vars : [1,1,1,0],
        min : [-3,-5,-2,-10],
        value : [0,0,0,0],
        max : [3,5,2,10],
        vscale : [0,0,0,0],
        answer : [1,3,-1,7]
      },
      29 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=|x-a|-|x-b|+c",
        func : (x,a,b,c,d) => {
          return Math.abs(x-a)-Math.abs(x-b)+c;
        },
        funcTangent : (x,a,b,c,d)=>{
          return x-3;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return 7-x;
        },
        xaxis : 470,//370
        yaxis : 460,//460
        gscale : 80,
        vars : [1,1,1,0],
        min : [-3,-3,-3,-10],
        value : [0,0,0,0],
        max : [3,3,3,10],
        vscale : [0,0,0,0],
        answer : [-1,2,1,7]
      },
      30 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=|x-a|-|x-b|+cx+d",
        func : (x,a,b,c,d) => {
          return Math.abs(x-a)-Math.abs(x-b)+c*x+d;
        },
        funcTangent : (x,a,b,c,d)=>{
          return x-3;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return 7-x;
        },
        xaxis : 370,//370
        yaxis : 560,//460
        gscale : 80,
        vars : [1,1,1,1],
        min : [-3,-3,-3,-3],
        value : [0,0,0,0],
        max : [3,3,3,3],
        vscale : [0,0,0,0],
        answer : [-2,0,-1,-2]
      },
      31 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=|asinbx+c|",
        func : (x,a,b,c,d) => {
          return Math.abs(a*Math.sin(b*x)+c);
        },
        funcTangent : (x,a,b,c,d)=>{
          return x-3;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return 7-x;
        },
        xaxis : 500,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,0],
        min : [-2,0,-5,-5],
        value : [2,3,0,0],
        max : [6,6,5,5],
        vscale : [0,0,0,0],
        answer : [4,2,1,5]
      },
      32 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=|x^2-a|-|x^2-b|+cx+d",
        func : (x,a,b,c,d) => {
          return Math.abs(x*x-a)-Math.abs(x*x-b)+c*x+d;
        },
        funcTangent : (x,a,b,c,d)=>{
          return x-3;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return 7-x;
        },
        xaxis : 370,//370
        yaxis : 560,//460
        gscale : 80,
        vars : [1,1,1,1],
        min : [-3,-3,-3,-3],
        value : [0,0,0,0],
        max : [3,3,3,3],
        vscale : [0,0,0,0],
        answer : [1,3,1,-1]
      },
      33 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=|x^2-a|-|x-b|+cx^2+d",
        func : (x,a,b,c,d) => {
          return Math.abs(x*x-a)-Math.abs(x-b)+c*x*x+d;
        },
        funcTangent : (x,a,b,c,d)=>{
          return x-3;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return 7-x;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,1],
        min : [-3,-3,-2,-3],
        value : [0,0,0,0],
        max : [3,3,2,3],
        vscale : [0,0,0,0],
        answer : [2,3,-1,2]
      },
      34 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=(x-a)|x-b|+cx+d",
        func : (x,a,b,c,d) => {
          return (x-a)*Math.abs(x-b)+c*x+d;
        },
        funcTangent : (x,a,b,c,d)=>{
          return x-3;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return 7-x;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,1],
        min : [-3,-3,-3,-3],
        value : [0,0,0,0],
        max : [3,3,3,3],
        vscale : [0,0,0,0],
        answer : [-1,1,-2,-1]
      },
      35 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=a|sin3x+b|-csinx+d",
        func : (x,a,b,c,d) => {
          return a*Math.abs(Math.sin(3*x)+b)-c*Math.sin(x)+d;
        },
        funcTangent : (x,a,b,c,d)=>{
          return x-3;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return 7-x;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 50,
        vars : [1,1,1,1],
        min : [-5,-1,-5,-5],
        value : [0,0,0,0],
        max : [5,1,5,5],
        vscale : [0,0,0,0],
        answer : [4,-.6,3,-5]
      },
      36 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=asin#||bx-c|-d#|",
        func : (x,a,b,c,d) => {
          return a*Math.sin(Math.abs(Math.abs(b*x-c)-d));
        },
        funcTangent : (x,a,b,c,d)=>{
          return x-3;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return 7-x;
        },
        xaxis : 400,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,1],
        min : [-5,-3,0,-10],
        value : [0,0,3,0],
        max : [5,3,6,10],
        vscale : [0,0,0,0],
        answer : [4,2,2,7]
      },
    };
    let problems4 = {
      37 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=ae^b^x",
        func : (x,a,b,c,d) => {
          return a*Math.exp(b*x);
        },
        funcTangent : (x,a,b,c,d)=>{
          return x-3;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return 7-x;
        },
        xaxis : 600,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,0,0],
        min : [-5,-5,0,-5],
        value : [0,0,5,0],
        max : [5,5,10,5],
        vscale : [0,0,0,0],
        answer : [2,2,8,3]
      },
      38 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=ae^b^x+c",
        func : (x,a,b,c,d) => {
          return a*Math.exp(b*x)+c;
        },
        funcTangent : (x,a,b,c,d)=>{
          return x-3;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return 7-x;
        },
        xaxis : 170,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,0],
        min : [-5,-3,-5,-5],
        value : [0,0,0,0],
        max : [5,3,5,5],
        vscale : [0,0,0,0],
        answer : [-1,1,-3,3]
      },
      39 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=aln(x-b)+c",
        func : (x,a,b,c,d) => {
          let r = a*Math.log(x-b)+c;
          if(Number.isNaN(r))return -Math.sign(a)*Infinity;
          return r;
        },
        funcTangent : (x,a,b,c,d)=>{
          return x-3;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return 7-x;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,0],
        min : [-5,-3,-3,-5],
        value : [0,0,0,0],
        max : [5,3,3,5],
        vscale : [0,0,0,0],
        answer : [1,-2,1,3]
      },
      40 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=ae^x+be^-^x+c",
        func : (x,a,b,c,d) => {
          return a*Math.exp(x)+b*Math.exp(-x)+c;
        },
        funcTangent : (x,a,b,c,d)=>{
          return x-3;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return 7-x;
        },
        xaxis : 500,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,0],
        min : [-1,-1,-3,-5],
        value : [0,0,0,0],
        max : [1,1,3,5],
        vscale : [0,0,0,0],
        answer : [.2,-.4,1,3]
      },
      41 : {
        type : "explicit",
        hide : 1,
        points : [3],
        tangent : 1,
        tangent2 : 0,
        funcstr : "y=e^x^-^a+b",
        func : (x,a,b,c,d) => {
          return Math.exp(x-a)+b;
        },
        funcTangent : (x,a,b,c,d)=>{
          return x-6;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return 7-x;
        },
        xaxis : 270,//370
        yaxis : 360,//460
        gscale : 60,
        vars : [1,1,0,0],
        min : [-5,-5,-5,-5],
        value : [0,0,0,0],
        max : [5,5,5,5],
        vscale : [0,0,0,0],
        answer : [3,-4,-5,3]
      },
      42 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=e^a^x^-^bsincx",
        func : (x,a,b,c,d) => {
          return Math.exp(a*x-b)*Math.sin(c*x);
        },
        funcTangent : (x,a,b,c,d)=>{
          return x-3;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return 7-x;
        },
        xaxis : 500,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,0],
        min : [-1,-3,-5,-5],
        value : [0,0,0,0],
        max : [1,3,5,5],
        vscale : [0,0,0,0],
        answer : [.2,-1,-5,3]
      },
      43 : {
        type : "explicit",
        hide : 1,
        points : [],
        tangent : 1,
        tangent2 : 1,
        funcstr : "y=e^a^x^-^bsin5x+c",
        func : (x,a,b,c,d) => {
          return Math.exp(a*x-b)*Math.sin(5*x)+c;
        },
        funcTangent : (x,a,b,c,d)=>{
          return Math.exp(a*x-b)+c;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -Math.exp(a*x-b)+c;
        },
        xaxis : 570,//370
        yaxis : 660,//460
        gscale : 60,
        vars : [1,1,1,0],
        min : [-1,-5,-5,-5],
        value : [0,0,0,0],
        max : [1,5,5,5],
        vscale : [0,0,0,0],
        answer : [.2,-2,3,3]
      },
      44 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=(ae^x^+be^-^x)sincx+d",
        func : (x,a,b,c,d) => {
          return (a*Math.exp(x)+b*Math.exp(-x))*Math.sin(c*x)+d;
        },
        funcTangent : (x,a,b,c,d)=>{
          return (a*Math.exp(x)+b*Math.exp(-x))+d;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -(a*Math.exp(x)+b*Math.exp(-x))+d;
        },
        xaxis : 570,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,1],
        min : [-1,-1,0,-5],
        value : [0,0,2,0],
        max : [1,1,4,5],
        vscale : [0,0,0,0],
        answer : [.2,.1,3,3]
      },
      45 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=e^3^s^i^n^a^x^+^b+c",
        func : (x,a,b,c,d) => {
          return Math.exp(3*Math.sin(a*x)+b)+c;
        },
        funcTangent : (x,a,b,c,d)=>{
          return Math.exp(a*x)+d+b;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return Math.exp(a*x)+d-b;
        },
        xaxis : 520,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,0],
        min : [-3,-3,-5,-5],
        value : [0,0,0,0],
        max : [3,3,5,5],
        vscale : [0,0,0,0],
        answer : [3,-1,-3,-3]
      },
      46 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=aln(bx^2+c)",
        func : (x,a,b,c,d) => {
          let r = a*Math.log(b*x*x+c);
          if(Number.isNaN(r))return -Math.sign(a)*Infinity;
          return r;
        },
        funcTangent : (x,a,b,c,d)=>{
          return (a*Math.exp(x)+b*Math.exp(-x))+d;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -(a*Math.exp(x)+b*Math.exp(-x))+d;
        },
        xaxis : 470,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,0],
        min : [-5,-5,-5,-5],
        value : [0,0,0,0],
        max : [5,5,5,5],
        vscale : [.1,0,0,0],
        answer : [1,4,5,3]
      },
      47 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=|e^a^x+b|+c",
        func : (x,a,b,c,d) => {
          return Math.abs(Math.exp(a*x)+b)+c;
        },
        funcTangent : (x,a,b,c,d)=>{
          return Math.exp(a*x)+d+b;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return Math.exp(a*x)+d-b;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,0],
        min : [-3,-5,-5,-5],
        value : [0,0,0,0],
        max : [3,5,5,5],
        vscale : [0,0,0,0],
        answer : [1,-4,-2,-3]
      },
      48 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=e^a^x+bcoscx+d",
        func : (x,a,b,c,d) => {
          return Math.exp(a*x)+b*Math.cos(c*x)+d;
        },
        funcTangent : (x,a,b,c,d)=>{
          return Math.exp(a*x)+d+b;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return Math.exp(a*x)+d-b;
        },
        xaxis : 170,//370
        yaxis : 360,//460
        gscale : 60,
        vars : [1,1,1,1],
        min : [-1,-5,0,-10],
        value : [0,0,2,0],
        max : [1,5,4,10],
        vscale : [0,0,0,0],
        answer : [.3,3,3,-6]
      },
    };
    let problems5 = {
      49 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=ax^3+bx",
        func : (x,a,b,c,d) => {
          return a*x*x*x+b*x;
        },
        funcTangent : (x,a,b,c,d)=>{
          return x-3;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return 7-x;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,0,0],
        min : [-3,-5,-5,-5],
        value : [0,0,0,0],
        max : [3,5,5,5],
        vscale : [0,0,0,0],
        answer : [1,-4,8,3]
      },
      50 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=(x-a)(x-b)(x-c)",
        func : (x,a,b,c,d) => {
          return (x-a)*(x-b)*(x-c);
        },
        funcTangent : (x,a,b,c,d)=>{
          return x-3;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return 7-x;
        },
        xaxis : 500,//370
        yaxis : 460,//460
        gscale : 50,
        vars : [1,1,1,0],
        min : [0,-4,-2,-5],
        value : [2,-2,0,0],
        max : [4,0,2,5],
        vscale : [0,0,0,0],
        answer : [3,-1,2,3]
      },
      51 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=#((x-a)^2-b#)^2-c",
        func : (x,a,b,c,d) => {
          return ((x-a)**2-b)**2-c;
        },
        funcTangent : (x,a,b,c,d)=>{
          return x-3;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return 7-x;
        },
        xaxis : 500,//370
        yaxis : 660,//460
        gscale : 50,
        vars : [1,1,1,0],
        min : [-5,-5,-5,-5],
        value : [0,0,0,0],
        max : [5,5,5,5],
        vscale : [0,0,0,0],
        answer : [-3,3,4,3]
      },
      52 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=x(x-a)(x-b)+c",
        func : (x,a,b,c,d) => {
          return x*(x-a)*(x-b)+c;
        },
        funcTangent : (x,a,b,c,d)=>{
          return x-3;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return 7-x;
        },
        xaxis : 500,//370
        yaxis : 560,//460
        gscale : 50,
        vars : [1,1,1,0],
        min : [-5,-3,-5,-5],
        value : [0,0,0,0],
        max : [5,3,5,5],
        vscale : [0,0,0,0],
        answer : [-4,-2,2,3]
      },
      53 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=a|x-b||x-c|(x-d)",
        func : (x,a,b,c,d) => {
          return a*Math.abs(x-b)*Math.abs(x-c)*(x-d);
        },
        funcTangent : (x,a,b,c,d)=>{
          return x-3;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return 7-x;
        },
        xaxis : 300,//370
        yaxis : 600,//460
        gscale : 40,
        vars : [1,1,1,1],
        min : [-1,-5,-3,-3],
        value : [0,0,0,0],
        max : [1,5,3,3],
        vscale : [0,0,0,0],
        answer : [.5,-5,1,-1]
      },
      54 : {
        type : "explicit",
        hide : 1,
        points : [-1,1],
        tangent : 1,
        tangent2 : 1,
        funcstr : "y=ax^3-3ax+b",
        func : (x,a,b,c,d) => {
          return a*x**3-3*a*x+b;
        },
        funcTangent : (x,a,b,c,d)=>{
          return 2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -6;
        },
        xaxis : 300,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,0,0],
        min : [-3,-5,-5,1],
        value : [0,0,0,3],
        max : [3,5,5,5],
        vscale : [0,0,0,0],
        answer : [2,-2,-2,2]
      },
      55 : {
        type : "explicit",
        hide : 1,
        points : [],
        tangent : 1,
        tangent2 : 1,
        funcstr : "y=(x^2-a)(x^2-b)",
        func : (x,a,b,c,d) => {
          return (x*x-a)*(x*x-b);
        },
        funcTangent : (x,a,b,c,d)=>{
          return 4;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -9/4;
        },
        xaxis : 500,//370
        yaxis : 460,//460
        gscale : 80,
        vars : [1,1,0,0],
        min : [-5,-2,-6,-5],
        value : [0,0,-3,0],
        max : [5,2,0,5],
        vscale : [0,0,0,0],
        answer : [4,1,-1,-1]
      },
      56 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=a(x-b)(x-c)|x-d|",
        func : (x,a,b,c,d) => {
          return a*(x-b)*(x-c)*Math.abs(x-d);
        },
        funcTangent : (x,a,b,c,d)=>{
          return 4;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -9/4;
        },
        xaxis : 300,//370
        yaxis : 460,//460
        gscale : 80,
        vars : [1,1,1,1],
        min : [-3,-3,-3,-3],
        value : [0,0,0,0],
        max : [3,3,3,3],
        vscale : [0,0,0,0],
        answer : [-1,1,1,-2]
      },
      57 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=a+#|(x^2+bx+c)^2-d#|",
        func : (x,a,b,c,d) => {
          return a+Math.abs((x*x+b*x+c)**2-d);
        },
        funcTangent : (x,a,b,c,d)=>{
          return 4;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -9/4;
        },
        xaxis : 300,//370
        yaxis : 460,//460
        gscale : 80,
        vars : [1,1,1,1],
        min : [-3,-3,-3,-2],
        value : [0,0,0,0],
        max : [3,3,3,2],
        vscale : [0,0,0,0],
        answer : [-2,-2,-1,1]
      },
      58 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=x(x-a)(x-b)(x-c)(x-d)",
        func : (x,a,b,c,d) => {
          return x*(x-a)*(x-b)*(x-c)*(x-d);
        },
        funcTangent : (x,a,b,c,d)=>{
          return 4;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -9/4;
        },
        xaxis : 500,//370
        yaxis : 360,//460
        gscale : 140,
        vars : [1,1,1,1],
        min : [-3,-4,2,1],
        value : [0,-1,3,3],
        max : [3,2,4,5],
        vscale : [0,0,0,0],
        answer : [0,0,2,2]
      },
      59 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=|ax^3-bx-c|-d",
        func : (x,a,b,c,d) => {
          return Math.abs(a*x**3-b*x-c)-d;
        },
        funcTangent : (x,a,b,c,d)=>{
          return x-3;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return 7-x;
        },
        xaxis : 400,//370
        yaxis : 460,//460
        gscale : 80,
        vars : [1,1,1,1],
        min : [-5,-6,-5,-5],
        value : [0,-2,0,0],
        max : [5,2,5,5],
        vscale : [0,0,0,0],
        answer : [-2,-4,4,3]
      },
      60 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=#|ax+(x-b)^2|x-c|#|+d",
        func : (x,a,b,c,d) => {
          return Math.abs(a*x+(x-b)**2*Math.abs(x-c))+d;
        },
        funcTangent : (x,a,b,c,d)=>{
          return a*x;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return 7-x;
        },
        xaxis : 500,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,1],
        min : [-5,0,-6,-5],
        value : [0,3,-3,0],
        max : [5,6,0,5],
        vscale : [0,0,0,0],
        answer : [-2,2,-1,-1]
      },
    };
    let problems6 = {
      61 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=F{a}{x-b}+c",
        func : (x,a,b,c,d) => {
          return a/(x-b)+c;
        },
        funcTangent : (x,a,b,c,d)=>{
          return 2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -6;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 50.001,//  綺麗な値にしない．
        vars : [1,1,1,0],
        min : [-5,-5,-5,1],
        value : [0,0,0,3],
        max : [5,5,5,5],
        vscale : [0,0,0,0],
        answer : [-3,2,-2,2]
      },
      62 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=F{a}{x-b}+cx+d",
        func : (x,a,b,c,d) => {
          return (a)/(x-b)+c*x+d;
        },
        funcTangent : (x,a,b,c,d)=>{
          return 2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -6;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 50.0001,//  綺麗な値にしない．
        vars : [1,1,1,1],
        min : [-3,-3,-3,-3],
        value : [0,0,0,0],
        max : [3,3,3,3],
        vscale : [0,0,0,0],
        answer : [1,1,1,-2]
      },
      63 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=F{1}{(x-a)(x-b)}+c",
        func : (x,a,b,c,d) => {
          return 1/(x-a)/(x-b)+c;
        },
        funcTangent : (x,a,b,c,d)=>{
          return 2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -6;
        },
        xaxis : 370,//370
        yaxis : 240.3,//460
        gscale : 70.0001,//  綺麗な値にしない．
        vars : [1,1,1,0],
        min : [-5,-4,-5,-5],
        value : [0,1,0,0],
        max : [5,6,5,5],
        vscale : [0,0,0,0],
        answer : [-1,6,-2,-2]
      },
      64 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=F{asinbx}{x-c}+d",
        func : (x,a,b,c,d) => {
          return (a*Math.sin(b*x))/(x-c)+d;
        },
        funcTangent : (x,a,b,c,d)=>{
          return 2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -6;
        },
        xaxis : 550,//370
        yaxis : 460,//460
        gscale : 50.0001,//  綺麗な値にしない．
        vars : [1,1,1,1],
        min : [-5,0,-5,-5],
        value : [0,3,0,0],
        max : [5,6,5,5],
        vscale : [0,0,0,0],
        answer : [-3,4,2,3]
      },
      65 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=F{ax}{x^2+bx+c}",
        func : (x,a,b,c,d) => {
          return (a*x)/(x*x+b*x+c);
        },
        funcTangent : (x,a,b,c,d)=>{
          return 2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -6;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 51,//  綺麗な値にしない．
        vars : [1,1,1,0],
        min : [-5,-3,-3,1],
        value : [0,0,0,3],
        max : [5,3,3,5],
        vscale : [0,0,0,0],
        answer : [5,0,1,2]
      },
      66 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=$|F{a}{|x-b|}-c$|+d",
        func : (x,a,b,c,d) => {
          return Math.abs((a)/Math.abs(x-b)-c)+d;
        },
        funcTangent : (x,a,b,c,d)=>{
          return 2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -6;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 71,//  綺麗な値にしない．
        vars : [1,1,1,1],
        min : [0,-5,-5,-5],
        value : [4,0,0,0],
        max : [8,5,5,5],
        vscale : [0,0,0,0],
        answer : [2,3,4,-2]
      },
      67 : {
        type : "explicit",
        hide : 1,
        points : [-1.62],
        tangent : 1,
        tangent2 : 1,
        funcstr : "y=F{asin3x}{x-b}+c",
        func : (x,a,b,c,d) => {
          return (a*Math.sin(3*x))/(x-b)+c;
        },
        funcTangent : (x,a,b,c,d)=>{
          return a/(x-b)+c;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -a/(x-b)+c;
        },
        xaxis : 250,//370
        yaxis : 660,//460
        gscale : 50.1,//  綺麗な値にしない．
        vars : [1,1,1,0],
        min : [-5,-5,-5,-5],
        value : [0,0,0,0],
        max : [5,5,5,5],
        vscale : [0,0,0,0],
        answer : [3,-3,-5,3]
      },
      68 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=asinF{b}{x^2+c}",
        func : (x,a,b,c,d) => {
          return a*Math.sin(b/(x*x+c));
        },
        funcTangent : (x,a,b,c,d)=>{
          return a/(x-b)+c;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -a/(x-b)+c;
        },
        xaxis : 470,//370
        yaxis : 460,//460
        gscale : 50.1,//  綺麗な値にしない．
        vars : [1,1,1,0],
        min : [-1,-3,-1,-2],
        value : [2,0,0,0],
        max : [5,3,1,2],
        vscale : [0,0,0,0],
        answer : [3,-3,.5,1]
      },
      69 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=F{a}{x-b}+cx+d|x|",
        func : (x,a,b,c,d) => {
          return a/(x-b)+c*x+d*Math.abs(x);
        },
        funcTangent : (x,a,b,c,d)=>{
          return a/(x-b)+c;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -a/(x-b)+c;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 50.1,//  綺麗な値にしない．
        vars : [1,1,1,1],
        min : [-3,-5,-3,-3],
        value : [0,0,0,0],
        max : [3,5,3,3],
        vscale : [0,0,0,0],
        answer : [-1,3,2,-3]
      },
      70 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=F{a}{|x+b|+c}+d",
        func : (x,a,b,c,d) => {
          return a/(Math.abs(x+b)+c)+d;
        },
        funcTangent : (x,a,b,c,d)=>{
          return a/(x-b)+c;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -a/(x-b)+c;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 50.1,//  綺麗な値にしない．
        vars : [1,1,1,1],
        min : [-3,-5,-3,-3],
        value : [0,0,0,0],
        max : [3,5,3,3],
        vscale : [0,0,0,0],
        answer : [-2,-3,-1,1]
      },
      71 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=F{a}{#||x+b|+c#|+d}",
        func : (x,a,b,c,d) => {
          return a/(Math.abs(Math.abs(x+b)+c)+d);
        },
        funcTangent : (x,a,b,c,d)=>{
          return a/(x-b)+c;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -a/(x-b)+c;
        },
        xaxis : 470,//370
        yaxis : 460,//460
        gscale : 50.1,//  綺麗な値にしない．
        vars : [1,1,1,1],
        min : [-3,-5,-3,-3],
        value : [0,0,0,0],
        max : [3,5,3,3],
        vscale : [0,0,0,0],
        answer : [-1,2,-3,-2]
      },
      72 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=F{sin(x-a)}{cos(bx-c)}+d",
        func : (x,a,b,c,d) => {
          return Math.sin(x-a)/Math.cos(b*x-c)+d;
        },
        funcTangent : (x,a,b,c,d)=>{
          return a/(x-b)+c;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -a/(x-b)+c;
        },
        xaxis : 370,//370
        yaxis : 660,//460
        gscale : 80.1,//  綺麗な値にしない．
        vars : [1,1,1,1],
        min : [-1,0,-1,-5],
        value : [0,2,0,0],
        max : [1,4,1,5],
        vscale : [0,0,0,0],
        answer : [-.5,3,-1,-2]
      },
    };
    let problems7 = {
      73 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=afloor(bx+c)",
        func : (x,a,b,c,d) => {
          return a*Math.floor(b*x+c);
        },
        funcTangent : (x,a,b,c,d)=>{
          return 2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -6;
        },
        xaxis : 200,//370
        yaxis : 300,//460
        gscale : 80.1,
        vars : [1,1,1,0],
        min : [0,-1,-3,1],
        value : [3,0,0,3],
        max : [6,1,3,5],
        vscale : [0,0,0,0],
        answer : [2,.5,-1,2]
      },
      74 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=mod(ax,b)+c",
        func : (x,a,b,c,d) => {
          return Math.mod(a*x,b)+c;
        },
        funcTangent : (x,a,b,c,d)=>{
          return 2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -6;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,0],
        min : [-1,-3,-3,1],
        value : [0,0,0,3],
        max : [1,3,3,5],
        vscale : [0,0,0,0],
        answer : [-.7,-2,-3,2]
      },
      75 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=mod(ax,b)+cx+d",
        func : (x,a,b,c,d) => {
          return Math.mod(a*x,b)+c*x+d;
        },
        funcTangent : (x,a,b,c,d)=>{
          return 2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -6;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 80,
        vars : [1,1,1,1],
        min : [-1,-3,-1,-2],
        value : [0,0,0,0],
        max : [1,3,1,2],
        vscale : [0,0,0,0],
        answer : [1,-2,.3,-1]
      },
      76 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=afloor(bx^2)+c",
        func : (x,a,b,c,d) => {
          return a*Math.floor(b*x*x)+c;
        },
        funcTangent : (x,a,b,c,d)=>{
          return 2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -6;
        },
        xaxis : 200,//370
        yaxis : 460,//460
        gscale : 80,
        vars : [1,1,1,0],
        min : [-1,-1,-1,-2],
        value : [0,0,0,0],
        max : [1,1,1,2],
        vscale : [0,0,0,0],
        answer : [1,-.3,-.6,-1]
      },
      77 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=afloor(bx)^2+c",
        func : (x,a,b,c,d) => {
          return a*Math.floor(b*x)**2+c;
        },
        funcTangent : (x,a,b,c,d)=>{
          return 2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -6;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 70,
        vars : [1,1,1,0],
        min : [-1,-1,-3,-2],
        value : [0,0,0,0],
        max : [1,1,3,2],
        vscale : [0,0,0,0],
        answer : [.5,-.6,-2,-1]
      },
      78 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=afloor#(bsin(cx+d)#)",
        func : (x,a,b,c,d) => {
          return a*Math.floor(b*Math.sin(c*x+d));
        },
        funcTangent : (x,a,b,c,d)=>{
          return 2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -6;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 70,
        vars : [1,1,1,1],
        min : [-2,0,-3,-1],
        value : [0,2,0,0],
        max : [2,4,3,1],
        vscale : [0,0,0,.1],
        answer : [1.5,1.3,-2,-.4]
      },
      79 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=asin#(bmod(x,c)#)+d",
        func : (x,a,b,c,d) => {
          return a*Math.sin(b*Math.mod(x,c))+d;
        },
        funcTangent : (x,a,b,c,d)=>{
          return 2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -6;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 70,
        vars : [1,1,1,1],
        min : [0,-1,-2,-3],
        value : [2,0,0,0],
        max : [4,1,2,3],
        vscale : [0,0,0,0],
        answer : [3,-1,2,1]
      },
      80 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=afloor(x)-floor(bx)+cx+d",
        func : (x,a,b,c,d) => {
          return a*Math.floor(x)-Math.floor(b*x)+c*x+d;
        },
        funcTangent : (x,a,b,c,d)=>{
          return 2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -6;
        },
        xaxis : 470,//370
        yaxis : 460,//460
        gscale : 70.1,
        vars : [1,1,1,1],
        min : [0,0,-2,-3],
        value : [2,2,0,0],
        max : [4,4,2,3],
        vscale : [0,0,0,0],
        answer : [2.5,1.5,-1,2]
      },
      81 : {
        //  厄介!!!
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=F{ax+b}{mod(x,c)+d}",
        func : (x,a,b,c,d) => {
          return (a*x+b)/(Math.mod(x,c)+d);
        },
        funcTangent : (x,a,b,c,d)=>{
          return 2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -6;
        },
        xaxis : 470,//370
        yaxis : 460,//460
        gscale : 70.0001,
        vars : [1,1,1,1],
        min : [0,0,-2,-3],
        value : [1,4,0,0],
        max : [2,8,2,3],
        vscale : [0,0,0,0],
        answer : [.4,5,2,2]
      },
      82 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=F{mod(x,a)+b}{mod(x,c)+d}",
        func : (x,a,b,c,d) => {
          return (Math.mod(x,a)+b)/(Math.mod(x,c)+d);
        },
        funcTangent : (x,a,b,c,d)=>{
          return 2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -6;
        },
        xaxis : 270,//370
        yaxis : 460,//460
        gscale : 50.0001,
        vars : [1,1,1,1],
        min : [0,0,0,-3],
        value : [2,2,1,0],
        max : [4,4,2,3],
        vscale : [0,0,0,0],
        answer : [3.3,2,1,-2]
      },
      83 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=aceil#(bmod(x,c)+d#)",
        func : (x,a,b,c,d) => {
          return a*Math.ceil(b*Math.mod(x,c)+d);
        },
        funcTangent : (x,a,b,c,d)=>{
          return 2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -6;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 80.0001,
        vars : [1,1,1,1],
        min : [0,-3,-3,-5],
        value : [3,0,1,0],
        max : [6,3,5,5],
        vscale : [0,0,0,0],
        answer : [1,1,4,-3]
      },
      84 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=acos#(x+bfloor(cx)#)+d",
        func : (x,a,b,c,d) => {
          return a*Math.cos(x+b*Math.floor(c*x))+d;
        },
        funcTangent : (x,a,b,c,d)=>{
          return 2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -6;
        },
        xaxis : 600,//370
        yaxis : 460,//460
        gscale : 80.001,
        vars : [1,1,1,1],
        min : [0,-2,-5,-5],
        value : [2,1,0,0],
        max : [4,4,5,5],
        vscale : [0,.1,0,0],
        answer : [2,3,2,3]
      },
    };
    let problems8 = {
      85 : {
        type : "explicit",
        skewx : .7,
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=F{1}{a}x^2+bx+c",
        func : (x,a,b,c,d) => {
          return x*x/a+b*x+c;
        },
        funcTangent : (x,a,b,c,d)=>{
          return 2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -6;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 80,
        vars : [1,1,1,0],
        min : [-5,-3,-3,1],
        value : [0,0,0,3],
        max : [5,3,3,5],
        vscale : [0,0,0,0],
        answer : [3,2,-1,2]
      },
      86 : {
        type : "explicit",
        skewx : 2,
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=2sin#(a#||x-b|-c#|-d#)",
        func : (x,a,b,c,d) => {
          return 2*Math.sin(a*Math.abs(Math.abs(x-b)-c)-d);
        },
        funcTangent : (x,a,b,c,d)=>{
          return 2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -6;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 80,
        vars : [1,1,1,1],
        min : [-3,0,-3,-1],
        value : [0,2,0,0],
        max : [3,4,3,1],
        vscale : [0,0,0,0],
        answer : [2,1,1.5,-.5]
      },
      87 : {
        type : "explicit",
        skewx : 3,
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=#(a#||x-b|-c#|-d#)^2",
        func : (x,a,b,c,d) => {
          return (a*Math.abs(Math.abs(x-b)-c)-d)**2;
        },
        funcTangent : (x,a,b,c,d)=>{
          return 2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -6;
        },
        xaxis : 470,//370
        yaxis : 460,//460
        gscale : 80,
        vars : [1,1,1,1],
        min : [0,0,-3,-2],
        value : [1,2,0,0],
        max : [2,4,3,2],
        vscale : [0,0,0,0],
        answer : [1,1,2,1]
      },
      88 : {
        type : "explicit",
        skewx : -2,
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=asinbx+cx+d",
        func : (x,a,b,c,d) => {
          return a*Math.sin(b*x)+c*x+d;
        },
        funcTangent : (x,a,b,c,d)=>{
          return 2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -6;
        },
        xaxis : 200,//370
        yaxis : 460,//460
        gscale : 80,
        vars : [1,1,1,1],
        min : [-3,0,-1,-3],
        value : [0,3,0,0],
        max : [3,6,1,3],
        vscale : [0,0,0,0],
        answer : [-1,4,-.4,-1]
      },
      89 : {
        type : "explicit",
        skewx : -1,
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=|x-a|-|x-b|+cx+d",
        func : (x,a,b,c,d) => {
          return Math.abs(x-a)-Math.abs(x-b)+c*x+d;
        },
        funcTangent : (x,a,b,c,d)=>{
          return 2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -6;
        },
        xaxis : 200,//370
        yaxis : 600,//460
        gscale : 80,
        vars : [1,1,1,1],
        min : [-3,0,-3,-3],
        value : [0,3,0,0],
        max : [3,6,3,3],
        vscale : [0,0,0,0],
        answer : [-2,4,-2,-2]
      },
      90 : {
        type : "explicit",
        skewx : 1,
        skewy : -1,
        hide : 1,
        points : [-2,2],
        tangent : 1,
        tangent2 : 0,
        funcstr : "y=F{x(x^2+a)}{b}+c",
        func : (x,a,b,c,d) => {
          return x*(x*x+a)/b+c;
        },
        funcTangent : (x,a,b,c,d)=>{
          return -4/3*x-2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -6;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,0],
        min : [-4,-4,-4,-3],
        value : [0,0,0,0],
        max : [4,4,4,3],
        vscale : [0,0,0,0],
        answer : [-4,3,-2,3]
      },
      91 : {
        type : "explicit",
        skewx : .7,
        skewy : .2,
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=F{ax+b}{x^2+c}+d",
        func : (x,a,b,c,d) => {
          return (a*x+b)/(x*x+c)+d;
        },
        funcTangent : (x,a,b,c,d)=>{
          return -4/3*x-2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -6;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 80,
        vars : [1,1,1,1],
        min : [-4,-4,-4,-3],
        value : [0,0,0,0],
        max : [4,4,4,3],
        vscale : [0,0,0,0],
        answer : [3,4,-3,-1]
      },
      92 : {
        type : "explicit",
        skewx : .2,
        skewy : -.5,
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=asinbxsincx+dx",
        func : (x,a,b,c,d) => {
          return a*Math.sin(b*x)*Math.sin(c*x)+d*x;
        },
        funcTangent : (x,a,b,c,d)=>{
          return -4/3*x-2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -6;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,1],
        min : [-4,0,0,-3],
        value : [0,2,4,0],
        max : [4,4,8,3],
        vscale : [0,0,0,0],
        answer : [2,1,8,-1]
      },
      93 : {
        type : "explicit",
        skewx : .2,
        skewy : .2,
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=F{ax-bfloor(cx)}{mod(x,d)+1}",
        func : (x,a,b,c,d) => {
          return (a*x-b*Math.floor(c*x))/(Math.mod(x,d)+1);
        },
        funcTangent : (x,a,b,c,d)=>{
          return -4/3*x-2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -6;
        },
        xaxis : 450,//370
        yaxis : 460,//460
        gscale : 100,
        vars : [1,1,1,1],
        min : [-4,-4,-2,-3],
        value : [0,0,0,0],
        max : [4,4,2,3],
        vscale : [0,0,.1,.1],
        answer : [-2,2,-1,2]
      },
      94 : {
        type : "explicit",
        skewx : 0,
        skewy : -.7,
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=#||acosbx+c|-d#|",
        func : (x,a,b,c,d) => {
          return Math.abs(Math.abs(a*Math.cos(b*x)+c)-d);
        },
        funcTangent : (x,a,b,c,d)=>{
          return 2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -6;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,1],
        min : [0,0,-3,-3],
        value : [2,1,0,0],
        max : [4,2,3,3],
        vscale : [0,0,0,0],
        answer : [4,1,1,3]
      },
      95 : {
        type : "explicit",
        skewx : 2,
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=cos#(asin(bx)#+c)+d",
        func : (x,a,b,c,d) => {
          return Math.cos(a*Math.sin(b*x)+c)+d;
        },
        funcTangent : (x,a,b,c,d)=>{
          return 2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -6;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 80,
        vars : [1,1,1,1],
        min : [-2,0,-3,-3],
        value : [1,2,0,0],
        max : [4,4,3,3],
        vscale : [0,0,0,0],
        answer : [3,1,-1,-1]
      },
      96 : {
        type : "explicit",
        skewx : 0,
        skewy : -.7,
        hide : 0,
        points : [],
        tangent : 0,
        tangent2 : 0,
        funcstr : "y=acosbx+csindx",
        func : (x,a,b,c,d) => {
          return a*Math.cos(b*x)+c*Math.sin(d*x);
        },
        funcTangent : (x,a,b,c,d)=>{
          return 2;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -6;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,1],
        min : [0,0,0,-2],
        value : [2,1.5,2,0],
        max : [4,3,4,2],
        vscale : [0,0,0,0],
        answer : [2,1,1,-2]
      },
    };
    let problems9 = {
      97  : {
        type : "polar",
        hide : 0,
        points : [],
        get range(){
          return [vars[2].value,vars[3].value,-3,2];
        },
        funcstr : "r=aθ+b (c<θ<d)",
        func : (x,a,b,c,d) => {
          return a*x+b;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 80,
        vars : [1,1,1,1],
        min : [-3,-3,-3,-3],
        value : [0,0,0,0],
        max : [3,3,3,3],
        vscale : [0,0,0,0],
        answer : [-1,-2,-3,2]
      },
      98  : {
        type : "polar",
        hide : 0,
        points : [],
        get range(){
          return [vars[2].value,vars[3].value,-1,3];
        },
        funcstr : "r=asinθ+b (c<θ<d)",
        func : (x,a,b,c,d) => {
          return a*Math.sin(x)+b;
        },
        xaxis : 570,//370
        yaxis : 460,//460
        gscale : 40,
        vars : [1,1,1,1],
        min : [-5,-5,-3,-3],
        value : [0,0,0,0],
        max : [5,5,3,3],
        vscale : [0,0,0,0],
        answer : [5,-3,-1,3]
      },
      99  : {
        type : "polar",
        hide : 0,
        points : [],
        get range(){
          return [vars[2].value,vars[3].value,-2,1];
        },
        funcstr : "r=asinbθ (c<θ<d)",
        func : (x,a,b,c,d) => {
          return a*Math.sin(b*x);
        },
        xaxis : 420,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,1],
        min : [-2,-5,-3,-3],
        value : [2,0,0,0],
        max : [6,5,3,3],
        vscale : [0,0,0,0],
        answer : [4,-4,-2,1]
      },
      100 : {
        type : "polar",
        hide : 0,
        points : [],
        get range(){
          return [0,Math.PI*2,0,Math.PI*2];
        },
        funcstr : "r=a#|sinbθ+c#|+d (0<θ<2π)",
        func : (x,a,b,c,d) => {
          return a*Math.abs(Math.sin(b*x)+c)+d;
        },
        xaxis : 420,//370
        yaxis : 460,//460
        gscale : 80,
        vars : [1,1,1,1],
        min : [0,-5,0,-3],
        value : [2,0,2,0],
        max : [4,5,4,3],
        vscale : [0,0,0,0],
        answer : [1,5,.5,-3]
      },
      101 : {
        type : "polar",
        hide : 0,
        points : [],
        get range(){
          return [vars[2].value,vars[3].value,-2,2];
        },
        funcstr : "r=F{asinθ+1}{bsinθ+1} (c<θ<d)",
        func : (x,a,b,c,d) => {
          return (a*Math.sin(x)+1)/(b*Math.sin(x)+1);
        },
        xaxis : 420,//370
        yaxis : 460,//460
        gscale : 160,
        vars : [1,1,1,1],
        min : [0,-5,-3,-3],
        value : [2,0,0,0],
        max : [4,5,3,3],
        vscale : [0,0,0,0],
        answer : [2,4,-2,2]
      },
      102 : {
        type : "polar",
        hide : 0,
        points : [],
        get range(){
          return [0,Math.PI*2,0,Math.PI*2];
        },
        funcstr : "r=amod(θ,b)+c (0<θ<2π)",
        func : (x,a,b,c,d) => {
          return a*Math.mod(x,b)+c;
        },
        xaxis : 420,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,0],
        min : [-3,-3,-3,-3],
        value : [0,0,0,0],
        max : [3,3,3,3],
        vscale : [0,0,0,0],
        answer : [3,1,2,1]
      },
      103 : {
        type : "polar",
        hide : 0,
        points : [],
        get range(){
          return [0,Math.PI*2,0,Math.PI*2];
        },
        funcstr : "r=F{aθ+b}{#|sin#(mod(θ,c)+d#)#|} (0<θ<2π)",
        func : (x,a,b,c,d) => {
          return (a*x+b)/(Math.abs(Math.sin(Math.mod(x,c)+d)));
        },
        xaxis : 420,//370
        yaxis : 460,//460
        gscale : 50,
        vars : [1,1,1,1],
        min : [0,0,0,0],
        value : [3,3,3,1.5],
        max : [6,6,6,3],
        vscale : [0,0,Math.PI/14,Math.PI/28],
        answer : [0,4,Math.PI*2/7,Math.PI*5/14]
      },
      104 : {
        type : "polar",
        hide : 0,
        points : [],
        get range(){
          return [vars[2].value,vars[3].value,2,5];
        },
        funcstr : "r=acos5θ+bcos3θ (c<θ<d)",
        func : (x,a,b,c,d) => {
          return a*Math.cos(5*x)+b*Math.cos(3*x);
        },
        xaxis : 420,//370
        yaxis : 460,//460
        gscale : 80,
        vars : [1,1,1,1],
        min : [0,0,0,0],
        value : [3,3,3,3],
        max : [6,6,6,6],
        vscale : [0,0,0,0],
        answer : [3,1,2,5]
      },
      105 : {
        type : "polar",
        hide : 0,
        points : [],
        get range(){
          return [vars[2].value*Math.PI,vars[3].value*Math.PI,-Math.PI*3,Math.PI*5];
        },
        funcstr : "r=afloor(bθ) (cπ<θ<dπ)",
        func : (x,a,b,c,d) => {
          return a*Math.floor(b*x);
        },
        xaxis : 420,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,1],
        min : [-1,-1,-8,0],
        value : [0,0,-4,4],
        max : [1,1,0,8],
        vscale : [0,.05,.1,.1],
        answer : [.5,-.6,-3,5]
      },
      106 : {
        type : "polar",
        hide : 0,
        points : [],
        get range(){
          return [0,Math.PI*2,0,Math.PI*2];
        },
        funcstr : "r=a|cosbθ|-c|sindθ| (0<θ<2π)",
        func : (x,a,b,c,d) => {
          return a*Math.abs(Math.cos(b*x))-c*Math.abs(Math.sin(d*x));
        },
        xaxis : 450,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,1],
        min : [-1,0,-5,0],
        value : [2,3,0,3],
        max : [5,6,5,6],
        vscale : [0,.1,0,.1],
        answer : [2,6,-3,3]
      },
      107 : {
        type : "polar",
        hide : 0,
        points : [],
        get range(){
          return [0,Math.PI*2,0,Math.PI*2];
        },
        funcstr : "r=F{a}{1+b|coscθ|sindθ} (0<θ<2π)",
        func : (x,a,b,c,d) => {
          return a/(1+b*Math.abs(Math.cos(c*x))*Math.sin(d*x));
        },
        xaxis : 500,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,1],
        min : [-5,0,0,0],
        value : [0,2,3,3],
        max : [5,4,6,6],
        vscale : [0,0,.1,.1],
        answer : [-3,.6,1,1]
      },
      108 : {
        type : "polar",
        hide : 0,
        points : [],
        get range(){
          return [0,Math.PI*10,0,Math.PI*10];
        },
        funcstr : "r=a#|mod(θ,b)-c#|+d (0<θ<10π)",
        func : (x,a,b,c,d) => {
          return a*Math.abs(Math.mod(x,b)-c)+d;
        },
        xaxis : 420,//370
        yaxis : 460,//460
        gscale : 50,
        vars : [1,1,1,1],
        min : [0,0,0,-5],
        value : [3,3,3,0],
        max : [6,6,6,5],
        vscale : [.2,Math.PI/32,Math.PI/32,.1],
        answer : [4,Math.PI*.625,Math.PI*.3125,2]
      },
    };
    let problems10 = {
      109 : {
        type : "parameter",
        hide : 0,
        points : [],
        get range(){
          return [vars[2].value,vars[3].value,1,4];
        },
        funcstr : "P{x=acost}{y=bsint} (c<t<d)",
        func : (t,a,b,c,d) => {
          return [a*Math.cos(t),b*Math.sin(t)];
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 120,
        vars : [1,1,1,1],
        min : [-3,-3,0,0],
        value : [0,0,2.5,2.5],
        max : [3,3,5,5],
        vscale : [0,0,0,0],
        answer : [-2,1,1,4]
      },
      110 : {
        type : "parameter",
        hide : 0,
        points : [],
        get range(){
          return [vars[2].value,vars[3].value,0,2];
        },
        funcstr : "P{x=ae^b^tcost}{y=ae^b^tsint} (c<t<d)",
        func : (t,a,b,c,d) => {
          return [a*Math.exp(b*t)*Math.cos(t),a*Math.exp(b*t)*Math.sin(t)];
        },
        xaxis : 420,//370
        yaxis : 460,//460
        gscale : 100,
        vars : [1,1,1,1],
        min : [-4,-2,0,0],
        value : [0,0,3,3],
        max : [4,2,6,6],
        vscale : [0,0,0,0],
        answer : [3,-1,0,2]
      },
      111 : {
        type : "parameter",
        hide : 0,
        points : [],
        get range(){
          return [vars[2].value,vars[3].value,0,3.5];
        },
        funcstr : "P{x=2cosat+sinbt}{y=2sinat+cosbt} (c<t<d)",
        func : (t,a,b,c,d) => {
          return [2*Math.cos(a*t)+Math.sin(b*t),2*Math.sin(a*t)+Math.cos(b*t)];
        },
        xaxis : 420,//370
        yaxis : 460,//460
        gscale : 80,
        vars : [1,1,1,1],
        min : [0,0,0,0],
        value : [2,2,2,2],
        max : [4,4,4,4],
        vscale : [.25,.25,0,0],
        answer : [2.5,3.75,0,3.5]
      },
      112 : {
        type : "parameter",
        hide : 0,
        points : [],
        get range(){
          return [vars[2].value,vars[3].value,-Math.PI/2,Math.PI/2];
        },
        funcstr : "P{x=4at-bsin4t}{y=a-bcos4t} (c<t<d)",
        func : (t,a,b,c,d) => {
          return [4*a*t-b*Math.sin(4*t),a-b*Math.cos(4*t)];
        },
        xaxis : 500,//370
        yaxis : 460,//460
        gscale : 80,
        vars : [1,1,1,1],
        min : [-2,-2,-3,-3],
        value : [0,0,0,0],
        max : [2,2,3,3],
        vscale : [0,0,0,0],
        answer : [.6,-.6,-Math.PI/2,Math.PI/2]
      },
      113 : {
        type : "parameter",
        hide : 0,
        points : [],
        get range(){
          return [vars[2].value,vars[3].value,-1,3];
        },
        funcstr : "P{x=asin^3t}{y=bcos^3t} (c<t<d)",
        func : (t,a,b,c,d) => {
          return [a*Math.sin(t)**3,b*Math.cos(t)**3];
        },
        xaxis : 420,//370
        yaxis : 460,//460
        gscale : 100,
        vars : [1,1,1,1],
        min : [0,0,-3,-3],
        value : [2,2,0,0],
        max : [4,4,3,3],
        vscale : [0,0,0,0],
        answer : [1,3,-1,3]
      },
      114 : {
        type : "parameter",
        hide : 0,
        points : [],
        get range(){
          return [-Math.PI,Math.PI,-Math.PI,Math.PI];
        },
        funcstr : "P{x=acosbt}{y=csindt} (-π<t<π)",
        func : (t,a,b,c,d) => {
          return [a*Math.cos(b*t),c*Math.sin(d*t)];
        },
        xaxis : 420,//370
        yaxis : 460,//460
        gscale : 120,
        vars : [1,1,1,1],
        min : [-2,0,0,0],
        value : [0,2,2,2],
        max : [2,4,4,4],
        vscale : [0,.05,0,.05],
        answer : [-2,3.5,2,3]
      },
      115 : {
        type : "parameter",
        hide : 0,
        points : [],
        get range(){
          return [-5,4,-5,4];
        },
        funcstr : "P{x=|t-a|-b}{y=#||t|-c#|-d} (-5<t<4)",
        func : (t,a,b,c,d) => {
          return [Math.abs(t-a)-b,Math.abs(Math.abs(t)-c)-d];
        },
        xaxis : 420,//370
        yaxis : 460,//460
        gscale : 120,
        vars : [1,1,1,1],
        min : [-3,-3,-3,-3],
        value : [0,0,0,0],
        max : [3,3,3,3],
        vscale : [0,0,0,0],
        answer : [-1,2,2,1]
      },
      116 : {
        type : "parameter",
        hide : 0,
        points : [],
        get range(){
          return [-1,2,-1,2];
        },
        funcstr : "P{x=at+bt^3}{y=c+dt^4} (-1<t<2)",
        func : (t,a,b,c,d) => {
          return [a*t+b*t**3,c+d*t**4];
        },
        xaxis : 240,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,1],
        min : [-3,-3,-3,-3],
        value : [0,0,0,0],
        max : [3,3,3,3],
        vscale : [0,.25,0,.2],
        answer : [3,-1.5,1,-.4]
      },
      117 : {
        type : "parameter",
        hide : 0,
        points : [],
        get range(){
          return [vars[2].value,vars[3].value,-2,-1];
        },
        funcstr : "P{x=t^2+a}{y=t^2+bt} (c<t<d)",
        func : (t,a,b,c,d) => {
          return [t*t+a,t*t+b*t];
        },
        xaxis : 420,//370
        yaxis : 460,//460
        gscale : 80,
        vars : [1,1,1,1],
        min : [-3,-3,-3,-3],
        value : [0,0,0,0],
        max : [3,3,3,3],
        vscale : [0,0,0,0],
        answer : [-2,3,-2,-1]
      },
      118 : {
        //  これは悪問かもしれない
        type : "parameter",
        hide : 0,
        points : [],
        get range(){
          return [0,8*Math.PI,0,8*Math.PI];
        },
        funcstr : "P{x=4cosat+2sinbt+cosct}{y=4sinat+2cosbt+sinct} (0<t<8π)",
        func : (t,a,b,c,d) => {
          return [4*Math.cos(a*t)+2*Math.sin(b*t)+Math.cos(c*t),4*Math.sin(a*t)+2*Math.cos(b*t)+Math.sin(c*t)];
        },
        xaxis : 420,//370
        yaxis : 460,//460
        gscale : 40,
        vars : [1,1,1,0],
        min : [0,0,0,0],
        value : [2,2,2,2],
        max : [4,4,4,4],
        vscale : [.25,.25,.25,0],
        answer : [.25,3.5,4,0]
      },
      119 : {
        type : "parameter",
        hide : 0,
        points : [],
        get range(){
          return [vars[2].value,vars[3].value,-2.4,2.6];
        },
        funcstr : "P{x=cos(t+acost)}{y=sin(t+bsint)} (c<t<d)",
        func : (t,a,b,c,d) => {
          return [Math.cos(t+a*Math.cos(t)),Math.sin(t+b*Math.sin(t))];
        },
        xaxis : 420,//370
        yaxis : 460,//460
        gscale : 200,
        vars : [1,1,1,1],
        min : [-3,-3,-3,-3],
        value : [0,0,0,0],
        max : [3,3,3,3],
        vscale : [0,0,0,0],
        answer : [2,-.5,-2.4,2.6]
      },
      120 : {
        type : "parameter",
        hide : 0,
        points : [],
        get range(){
          return [vars[2].value,vars[3].value,0,6];
        },
        funcstr : "P{x=cos(2t+a)}{y=t^0^.^3sin(t+b)} (c<t<d)",
        func : (t,a,b,c,d) => {
          return [Math.cos(2*t+a),t**.3*Math.sin(t+b)];
        },
        xaxis : 420,//370
        yaxis : 460,//460
        gscale : 120,
        vars : [1,1,1,1],
        min : [-3,-3,0,0],
        value : [0,0,4,4],
        max : [3,3,8,8],
        vscale : [0,0,0,0],
        answer : [.5,-2,0,6]
      },
    }
    let problems11 = {
      121 : {
        type : "implicit",
        hide : 0,
        points : [],
        funcstr : "a(x-b)^2+c(y-d)^2=1",
        func : (x,y,a,b,c,d) => {
          return a*(x-b)**2+c*(y-d)**2-1;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 120,
        vars : [1,1,1,1],
        min : [-3,-3,-3,-3],
        value : [0,0,0,0],
        max : [3,3,3,3],
        vscale : [0,0,0,0],
        answer : [2,-1,1,-1]
      },
      122 : {
        type : "implicit",
        hide : 0,
        points : [],
        funcstr : "F{(x-a)^2}{b}+F{(y-c)^2}{d}=1",
        func : (x,y,a,b,c,d) => {
          return (x-a)**2/b+(y-c)**2/d-1;
        },
        xaxis : 420,//370
        yaxis : 460,//460
        gscale : 80,
        vars : [1,1,1,1],
        min : [-3,-3,-3,-3],
        value : [0,0,0,0],
        max : [3,3,3,3],
        vscale : [0,0,0,0],
        answer : [2,-2,-1,1]
      },
      123 : {
        type : "implicit",
        hide : 0,
        points : [],
        funcstr : "(y-a)^2=b(x-c)(x-d)^2",
        func : (x,y,a,b,c,d) => {
          return (y-a)**2-b*(x-c)*(x-d)**2;
        },
        xaxis : 200,//370
        yaxis : 460,//460
        gscale : 80,
        vars : [1,1,1,1],
        min : [-3,-3,-3,-3],
        value : [0,0,0,0],
        max : [3,3,3,3],
        vscale : [0,0,0,0],
        answer : [-2,1,-2,1]
      },
      124 : {
        type : "implicit",
        hide : 0,
        points : [],
        funcstr : "x^2+y^2-1=max(ax+by,cx+dy)",
        func : (x,y,a,b,c,d) => {
          return x*x+y*y-1-Math.max(a*x+b*y,c*x+d*y);
        },
        xaxis : 500,//370
        yaxis : 460,//460
        gscale : 100,
        vars : [1,1,1,1],
        min : [-4,-4,0,0],
        value : [-2,-2,2,2],
        max : [0,0,4,4],
        vscale : [0,0,0,0],
        answer : [-2,-1,1,3]
      },
      125 : {
        type : "implicit",
        hide : 0,
        points : [],
        funcstr : "sin(ax)sin(by)sin(cx+dy)=0",
        func : (x,y,a,b,c,d) => {
          return Math.sin(a*x)*Math.sin(b*y)*Math.sin(c*x+d*y);
        },
        xaxis : 500,//370
        yaxis : 460,//460
        gscale : 100,
        vars : [1,1,1,1],
        min : [0,0,0,0],
        value : [1,1,1,1],
        max : [2,2,2,2],
        vscale : [0,0,0,0],
        answer : [1,1,1,2]
      },
      126 : {
        type : "implicit",
        hide : 0,
        points : [],
        funcstr : "((x-a)^2+(y-b)^2-c)(x^2+y^2-1)=d",
        func : (x,y,a,b,c,d) => {
          return ((x-a)**2+(y-b)**2-c)*(x**2+y**2-1)-d;
        },
        xaxis : 300,//370
        yaxis : 460,//460
        gscale : 100,
        vars : [1,1,1,1],
        min : [-3,-3,-3,-3],
        value : [0,0,0,0],
        max : [3,3,3,3],
        vscale : [0,0,0,0],
        answer : [2,-2,2,1]
      },
      127 : {
        type : "implicit",
        hide : 0,
        points : [],
        funcstr : "max#((x-a)^2+(y-b)^2,(x-c)^2+(y-d)^2#)=1",
        func : (x,y,a,b,c,d) => {
          return Math.max((x-a)**2+(y-b)**2,(x-c)**2+(y-d)**2)-1;
        },
        xaxis : 300,//370
        yaxis : 460,//460
        gscale : 120,
        vars : [1,1,1,1],
        min : [-3,-3,-1,-3],
        value : [0,0,0,0],
        max : [3,3,1,3],
        vscale : [0,0,0,0],
        answer : [-2,0,-1,-1]
      },
      128 : {
        type : "implicit",
        hide : 0,
        points : [],
        funcstr : "min$((x-a)^2+(y-b)^2,F{(x-c)^2+(y-d)^2}{2}$)=1",
        func : (x,y,a,b,c,d) => {
          return Math.min((x-a)**2+(y-b)**2,((x-c)**2+(y-d)**2)/2)-1;
        },
        xaxis : 300,//370
        yaxis : 460,//460
        gscale : 120,
        vars : [1,1,1,1],
        min : [-3,-3,-3,-3],
        value : [0,0,0,0],
        max : [3,3,3,3],
        vscale : [0,0,0,0],
        answer : [1,0,1,-2]
      },
      129 : {
        type : "implicit",
        hide : 0,
        points : [],
        funcstr : "max$(F{x^2}{a}+F{y^2}{b}+1,F{x^2}{c}+F{y^2}{d}-1$)=0",
        func : (x,y,a,b,c,d) => {
          return Math.max(x*x/a+y*y/b+1,x*x/c+y*y/d-1);
        },
        xaxis : 420,//370
        yaxis : 460,//460
        gscale : 120,
        vars : [1,1,1,1],
        min : [-4,-4,-4,-4],
        value : [0,0,0,0],
        max : [4,4,4,4],
        vscale : [0,0,0,0],
        answer : [3,-1,4,3]
      },
      130 : {
        type : "implicit",
        hide : 0,
        points : [],
        funcstr : "(y-a)^2=bx+c",
        func : (x,y,a,b,c,d) => {
          return (y-a)**2-b*x-c;
        },
        xaxis : 270,//370
        yaxis : 460,//460
        gscale : 120,
        vars : [1,1,1,0],
        min : [-3,-3,-3,-3],
        value : [0,0,0,0],
        max : [3,3,3,3],
        vscale : [0,0,0,0],
        answer : [-1,-2,2,0]
      },
      131 : {
        type : "implicit",
        hide : 0,
        points : [],
        funcstr : "(y+a)(xsinb+ycosb+c)=d",
        func : (x,y,a,b,c,d) => {
          return (y+a)*(x*Math.sin(b)+y*Math.cos(b)+c)-d;
        },
        xaxis : 300,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,1],
        min : [-3,-1,-3,-3],
        value : [0,0,0,0],
        max : [3,1,3,3],
        vscale : [0,0,0,0],
        answer : [2,-.7,2,-1]
      },
      132 : {
        type : "implicit",
        hide : 0,
        points : [],
        funcstr : "x^2+y^2+axy+bx+cy=1",
        func : (x,y,a,b,c,d) => {
          return x*x+y*y+a*x*y+b*x+c*y-1;
        },
        xaxis : 300,//370
        yaxis : 600,//460
        gscale : 80,
        vars : [1,1,1,0],
        min : [-3,-3,-3,-3],
        value : [0,0,0,0],
        max : [3,3,3,3],
        vscale : [0,0,0,0],
        answer : [-1.2,1.5,1,-1]
      },
    }
    let problems12 = {
      133 : {
        type : "implicit",
        hide : 0,
        points : [],
        funcstr : "#|x^2+a#(|y|+b#)^2+c#|=d",
        func : (x,y,a,b,c,d) => {
          return Math.abs(x*x+a*(Math.abs(y)+b)**2+c)-d;
        },
        xaxis : 420,//370
        yaxis : 460,//460
        gscale : 80,
        vars : [1,1,1,1],
        min : [-3,-3,-5,-3],
        value : [0,0,0,0],
        max : [3,3,5,3],
        vscale : [0,0,0,0],
        answer : [1.6,-1.5,-4,1]
      },
      134 : {
        type : "implicit",
        hide : 0,
        points : [],
        funcstr : "a#||x|+b#|+c#||y|+d#|=1",
        func : (x,y,a,b,c,d) => {
          return a*Math.abs(Math.abs(x)+b)+c*Math.abs(Math.abs(y)+d)-1;
        },
        xaxis : 420,//370
        yaxis : 460,//460
        gscale : 120,
        vars : [1,1,1,1],
        min : [-3,-3,-3,-3],
        value : [0,0,0,0],
        max : [3,3,3,3],
        vscale : [0,0,0,0],
        answer : [1,-2,3,-1]
      },
      135 : {
        type : "implicit",
        hide : 0,
        points : [],
        funcstr : "x^2+y^2+a|x|+b|y|+cx+dy=1",
        func : (x,y,a,b,c,d) => {
          return x*x+y*y+a*Math.abs(x)+b*Math.abs(y)+c*x+d*y-1;
        },
        xaxis : 330,//370
        yaxis : 460,//460
        gscale : 80,
        vars : [1,1,1,1],
        min : [-3,-3,-3,-3],
        value : [0,0,0,0],
        max : [3,3,3,3],
        vscale : [0,0,0,0],
        answer : [-2,-1.5,-1,1]
      },
      136 : {
        type : "implicit",
        hide : 0,
        points : [],
        funcstr : "#||x|+y-a#|=bx^2+cy^2-|x|-y+d^2",
        func : (x,y,a,b,c,d) => {
          return b*x*x+c*y*y-Math.abs(x)-y+d*d-Math.abs(Math.abs(x)+y-a);
        },
        xaxis : 420,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,1],
        min : [-5,-2,-2,0],
        value : [0,0,0,1.5],
        max : [5,2,2,3],
        vscale : [0,1/9,1/9,0],
        answer : [4,1/3,1/3,1]
      },
      137 : {
        type : "implicit",
        hide : 0,
        points : [],
        funcstr : "#||x+y+a|+b#|+#||x-y|+c#|=d",
        func : (x,y,a,b,c,d) => {
          return Math.abs(Math.abs(x+y+a)+b)+Math.abs(Math.abs(x-y)+c)-d;
        },
        xaxis : 320,//370
        yaxis : 500,//460
        gscale : 60,
        vars : [1,1,1,1],
        min : [-3,-3,-3,-3],
        value : [0,0,0,0],
        max : [3,3,3,3],
        vscale : [0,0,0,0],
        answer : [2,-3,-2,3]
      },
      138 : {
        type : "implicit",
        hide : 0,
        points : [],
        funcstr : "a|x|+b|y|+#||x-y|+c|x|#|=d",
        func : (x,y,a,b,c,d) => {
          return a*Math.abs(x)+b*Math.abs(y)+Math.abs(Math.abs(x-y)+c*Math.abs(x))-d;
        },
        xaxis : 420,//370
        yaxis : 460,//460
        gscale : 80,
        vars : [1,1,1,1],
        min : [-3,-3,-3,-3],
        value : [0,0,0,0],
        max : [3,3,3,3],
        vscale : [.1,0,.1,0],
        answer : [1.5,0,-1.5,2]
      },
      139 : {
        type : "implicit",
        hide : 0,
        points : [],
        funcstr : "(|x|+a)#(#||x|+b#|+c#)+dy^2=1",
        func : (x,y,a,b,c,d) => {
          return (Math.abs(x)+a)*(Math.abs(Math.abs(x)+b)+c)+d*y*y-1;
        },
        xaxis : 420,//370
        yaxis : 460,//460
        gscale : 80,
        vars : [1,1,1,1],
        min : [-3,-3,-3,-3],
        value : [0,0,0,0],
        max : [3,3,3,3],
        vscale : [0,0,0,0],
        answer : [-3,-3,-2,1]
      },
      140 : {
        type : "implicit",
        hide : 0,
        points : [],
        funcstr : "#||x+a|+b#|=#||y|+c#|+d",
        func : (x,y,a,b,c,d) => {
          return Math.abs(Math.abs(x+a)+b)-Math.abs(Math.abs(y)+c)-d;
        },
        xaxis : 420,//370
        yaxis : 460,//460
        gscale : 80,
        vars : [1,1,1,1],
        min : [-3,-3,-3,-3],
        value : [0,0,0,0],
        max : [3,3,3,3],
        vscale : [0,0,0,0],
        answer : [1,-2,-2,1]
      },
      141 : {
        type : "implicit",
        hide : 0,
        points : [],
        funcstr : "max#(#||ax|-y#|,#||by|+x+c#|#)=d",
        func : (x,y,a,b,c,d) => {
          return Math.max(Math.abs(Math.abs(a*x)-y),Math.abs(Math.abs(b*y)+x+c))-d;
        },
        xaxis : 460,//370
        yaxis : 460,//460
        gscale : 100,
        vars : [1,1,1,1],
        min : [0,0,-3,-3],
        value : [3,3,0,0],
        max : [6,6,3,3],
        vscale : [0,0,0,0],
        answer : [3,2,-3,1.5]
      },
      142 : {
        type : "implicit",
        hide : 0,
        points : [],
        funcstr : "max#(#||ax+by|-x#|,|y+c|#)=d",
        func : (x,y,a,b,c,d) => {
          return Math.max(Math.abs(Math.abs(a*x+b*y)-x),Math.abs(y+c))-d;
        },
        xaxis : 600,//370
        yaxis : 100,//460
        gscale : 50,
        vars : [1,1,1,1],
        min : [0,-3,-3,-3],
        value : [2,0,0,0],
        max : [4,3,3,3],
        vscale : [0,0,0,0],
        answer : [2,-2,-3,3]
      },
      143 : {
        type : "implicit",
        hide : 0,
        points : [],
        funcstr : "min#(a#||x|+by#|-y,#||x|+cy#|+|x|#)=d",
        func : (x,y,a,b,c,d) => {
          return Math.min(a*Math.abs(Math.abs(x)+b*y)-y,Math.abs(Math.abs(x)+c*y)+Math.abs(x))-d;
        },
        xaxis : 420,//370
        yaxis : 460,//460
        gscale : 90,
        vars : [1,1,1,1],
        min : [-2,-3,-3,-3],
        value : [0,0,0,0],
        max : [2,3,3,3],
        vscale : [0,0,0,0],
        answer : [2,1,-3,3]
      },
      144 : {
        type : "implicit",
        hide : 0,
        points : [],
        funcstr : "#|a(|x|+by)^2+y^2+c#|=d",
        func : (x,y,a,b,c,d) => {
          return Math.abs(a*(Math.abs(x)+b*y)**2+y*y+c)-d;
        },
        xaxis : 460,//370
        yaxis : 460,//460
        gscale : 120,
        vars : [1,1,1,1],
        min : [-5,-2,-5,-5],
        value : [0,0,0,0],
        max : [5,2,5,5],
        vscale : [0,0,0,0],
        answer : [4,-.5,-4,2]
      },
    }

    let problems = {
      ...problems0,
      ...problems1,
      ...problems2,
      ...problems3,
      ...problems4,
      ...problems5,
      ...problems6,
      ...problems7,
      ...problems8,
      ...problems9,
      ...problems10,
      ...problems11,
      ...problems12
    }




    //  フォントの読み込み後に開始
    WebFont.load({
      //custom : {
      custom : {
        families : ["Roboto Mono"]
      },
      active : () => {
        save = 1;
        Init();

        //  URLパラメータがあれば, 適用する
        //  自信ない表現???
        if(location.search.match(/from=(\d+|Infinity)/)){
          let l = +location.search.match(/from=(\d+|Infinity)/)[1];
          if(!Number.isNaN(l)){
            save = 0;
            Unlock(Infinity);
            if(l === Infinity){
              level = 0;
              Reset(2);
              level = 1;
            }
            else{
              level = Math.min(l,Object.keys(problems).reduce((a,b)=>Math.max(+a,+b)));
              Reset(2);
            }
          }
        }

        //  リサイズ時, canvasを画面の大きさに合わせる
        window.onresize = () => {Resize();}
        //  操作
        if(window.ontouchstart === null){
          //  タッチ操作
          cvs.ontouchstart = (e) => {
            if(!ctrl)return 0;
            if(clear===1){
              clear = 2;
              DrawAll();
            }
            e.preventDefault();
            let x = e.touches[0].clientX-cvs.getBoundingClientRect().left;//  canvas左上からのpx値
            let y = e.touches[0].clientY-cvs.getBoundingClientRect().top;
            let wp = cvs.width;
            let wr = cvs.getBoundingClientRect().width;
            let hp = cvs.height;
            let hr = cvs.getBoundingClientRect().height;
            let r = window.innerWidth/20;

            //  スライダーの判定
            for(let i=0; i<4; i++){
              ctx.fillStyle = "#ff00ff20";
              ctx.fillRect(vars[i].proportion*600+200-50,950+i*130-50,100,100);
              if(IsIn(x,y,(vars[i].proportion*600+200)/wp*wr-r,(950+i*130)/wp*wr-r,r*2,r*2)){//  canvas内の点の座標を戻す
                buttons.slider = i;
                break;
              }
            }

            //  ボタンの判定
            if(IsIn(x,y,40/wp*wr,1510/wp*wr,280/wp*wr,100/wp*wr)&&buttons.prev.available){
              Prev(1);
            };
            if(IsIn(x,y,360/wp*wr,1510/wp*wr,280/wp*wr,100/wp*wr)&&buttons.reset.available){
              Reset(1);
            };
            if(IsIn(x,y,680/wp*wr,1510/wp*wr,280/wp*wr,100/wp*wr)&&buttons.next.available){
              Next(1);
            };

            //  タッチ操作は一つのみ有効
            ctrl = 0;
            DrawAll();
          }
          cvs.ontouchmove = (e) => {
            e.preventDefault();
            let x = e.touches[0].clientX-cvs.getBoundingClientRect().left;
            x *= cvs.width;
            x /= cvs.getBoundingClientRect().width;
            let v;

            //  スライダー操作
            if(0<=buttons.slider){
              v = vars[buttons.slider];
              let d = Math.round(v.proportion*10)/10;
              v.value = (v.max-v.min)*Math.min(Math.max((x-200)/600,0),1)+v.min;
              v.adapt();
              d = Math.round(v.proportion*10)/10-d;
              if(.04<Math.abs(d)){
              }
              SetButtons();
            }
            DrawAll();

            if(graph.type === "title" || graph.type === "congrats"){
              Check();
            }
            else if(graph.type === "settings"){
              AdaptSettings();
            }
          }
          window.ontouchend = () => {
            buttons.slider = -1;
            Check();
            ctrl = 1;
          }
        }
        else{
          //  マウス操作
          cvs.onmousedown = (e) => {
            if(!ctrl)return 0;
            if(clear===1){
              clear = 2;
              DrawAll();
            }
            e.preventDefault();
            let x = e.offsetX;//  canvas左上からのpx値
            let y = e.offsetY;
            let wp = cvs.width;
            let wr = cvs.getBoundingClientRect().width;
            let hp = cvs.height;
            let hr = cvs.getBoundingClientRect().height;
            let r = Math.min(window.innerWidth/20,window.innerHeight/33);

            //  スライダーの判定
            for(let i=0; i<4; i++){
              ctx.fillStyle = "#ff00ff20";
              ctx.fillRect(vars[i].proportion*600+200-50,950+i*130-50,100,100);
              if(IsIn(x,y,(vars[i].proportion*600+200)/wp*wr-r,(950+i*130)/wp*wr-r,r*2,r*2)){//  canvas内の点の座標を戻す
                buttons.slider = i;
                break;
              }
            }

            //  ボタンの判定
            if(IsIn(x,y,40/wp*wr,1510/wp*wr,280/wp*wr,100/wp*wr)&&buttons.prev.available){
              Prev(1);
            };
            if(IsIn(x,y,360/wp*wr,1510/wp*wr,280/wp*wr,100/wp*wr)&&buttons.reset.available){
              Reset(1);
            };
            if(IsIn(x,y,680/wp*wr,1510/wp*wr,280/wp*wr,100/wp*wr)&&buttons.next.available){
              Next(1);
            };

            //  タッチ操作は一つのみ有効
            ctrl = 0;
            DrawAll();
          }
          cvs.onmousemove = (e) => {
            e.preventDefault();
            let x = e.offsetX;
            x *= cvs.width;
            x /= cvs.getBoundingClientRect().width;
            let v;

            //  スライダー操作
            if(0<=buttons.slider){
              v = vars[buttons.slider];
              let d = Math.round(v.proportion*10)/10;
              v.value = (v.max-v.min)*Math.min(Math.max((x-200)/600,0),1)+v.min;
              v.adapt();
              d = Math.round(v.proportion*10)/10-d;
              if(.04<Math.abs(d)){
              }
              SetButtons();
            }
            DrawAll();

            if(graph.type === "title" || graph.type === "congrats"){
              Check();
            }
            else if(graph.type === "settings"){
              AdaptSettings();
            }
          }
          window.onmouseup = () => {
            buttons.slider = -1;
            Check();
            ctrl = 1;
          }
        }
      },
      inactive : () => {
        alert("フォント読み込み失敗");
      }
    });




    function LoadCookie(){
      cdata0 = {
        maxlevel : 1,
        analog : 0,
        color : 0,
        weight : 10
      };
      if(!document.cookie.length){
        //  初訪問
        cdata = {};
        for(let k in cdata0){
          cdata[k] = cdata0[k];
        }
      }
      else{
        let cookies = document.cookie.split(";");
        if(cookies.length < Object.keys(cdata0).length){
          //  cookieの数が足りない => 更新をまたいだ
          ClearCookie();
          LoadCookie();
          return 0;
        }
        cdata = {};
        for(let i=0; i<cookies.length; i++){
          cdata[cookies[i].split("=")[0].replace(/\s/g,"")] = +decodeURIComponent(cookies[i].split("=")[1]);
        }
      }
      colors = {
        get main(){return ["#ffff00","#00ffff","#e000ff","#ff8000"][cdata.color];},
        get main_(){return ["#ffff0040","#00ffff40","#e000ff40","#ff800040"][cdata.color];},
        get hint(){return ["#00ffff","#ff0040","#ffc000","#ffff00"][cdata.color];},
        get disabled(){return ["#888888"][0];},
        get disabled_(){return ["#88888840"][0];},
        get message(){return ["#ffffff"][0];},
        get message_(){return ["#ffffff40"][0];}
      }
    }

    function SaveCookie(){
      //  2038年問題???!!
      if(!save)return 0;
      for(let k in cdata){
        document.cookie =  `${k}=${encodeURIComponent(String(cdata[k]))}; max-age=315360000;`;//  10年
      }
    }

    function ClearCookie(){
      let cookies = document.cookie.split(";");
      for(let i=0; i<cookies.length; i++){
        document.cookie = `${cookies[i]};max-age=0;`;
      }
    }

    function Resize(){
      let len = Math.min(window.innerWidth/20,window.innerHeight/33)*.95;
      bvs.style.width = `${len*20}px`;
      cvs.style.width = `${len*20}px`;
      document.querySelector("#wrapper").style.height = `${window.innerHeight}px`;
    }

    function Init(){
      bvs = document.querySelector("#background_canvas");
      btx = bvs.getContext("2d");
      btx.lineJoin = "round";
      btx.lineCap = "round";
      cvs = document.querySelector("#main_canvas");
      ctx = cvs.getContext("2d");
      ctx.lineJoin = "round";
      ctx.lineCap = "round";
      ctx.shadowColor = "#c0ffc0";
      touches = {};
      buttons = {
        prev : {
          //down : 0,  ボタン押下時の見た目はそのままでよいのか!!!???
          available : 0
        },
        reset : {
          //down : 0,
          available : 1
        },
        next : {
          //down : 0,
          available : 0
        },
        slider : -1
      };
      graph = {
        colors : {
          get main(){return cdata.analog ? "#d0ffd0" : colors.main;},
          get main_(){return cdata.analog ? "#d0ffd040" : colors.main_;},
          get hint(){return cdata.analog ? "#d0ffd0" : colors.hint;},
          get disabled(){return cdata.analog ? "#80a080" : colors.disabled;},
          get disabled_(){return cdata.analog ? "#80a08040" : colors.disabled_;},
          get message(){return cdata.analog ? "#d0ffd0" : colors.message;},
          get message_(){return cdata.analog ? "#d0ffd040" : colors.message_;}
        }
      };
      vars = [];
      for(let i=0; i<4; i++){
        vars.push({});
        Object.defineProperty(vars[i],"proportion",{
          get : () => {
            let v = vars[i];
            return (v.value-v.min)/(v.max-v.min);
          }
        });
        Object.defineProperty(vars[i],"adapt",{
          value : () => {
            let v = vars[i];
            if(v.scale){
              v.value = v.scale*Math.round((v.value-v.min)/v.scale)+v.min;
            }
          }
        });
      }
      ctrl = 1;//  使用した記憶なし．要確認!!!
      level = 0;//  0はタイトル画面
      clear = 0;//  レベルごとに使用. 0:未, 1:済

      //  クッキーがあれば，そのデータを代入する
      LoadCookie();
      let lvl = cdata.maxlevel>=145 ? 1 : cdata.maxlevel;

      //  Resetによる初期化
      Resize();
      Reset(2);
      level = lvl;
    }

    //  ボタン設定
    function SetButtons(){
      if(graph.type==="title"){
        buttons.prev.available = 1;
        buttons.reset.available = 1;
      }
      else if(graph.type === "stages"){
        buttons.prev.available = 1;
        if(vars[0].value-1+(vars[1].value-1)*4<=Math.ceil(cdata.maxlevel/12)-1){
          //  nextボタン
          buttons.next.available = 1;
        }else{
          buttons.next.available = 0;
        }
        buttons.reset.available = 1;
      }
      else if(graph.type === "settings"){
        buttons.prev.available = 1;
        buttons.next.available = 0;
        buttons.reset.available = 1;
      }
      else if(graph.type === "levels"){
        if(vars[0].value+(vars[1].value-1)*4<=cdata.maxlevel){
          //  nextボタン
          buttons.next.available = 1;
        }else{
          buttons.next.available = 0;
        }
        buttons.reset.available = 1;
      }
      else{
        buttons.prev.available = level<=144 ? 1 : 0;
        buttons.reset.available = 1;
        buttons.next.available = +(level<cdata.maxlevel);
      }
    }

    //  設定の適用
    function AdaptSettings(){
      cdata.analog = vars[0].value;
      cdata.color = vars[1].value;
      cdata.weight = vars[2].value;
      SaveCookie();
      DrawAll(1);
    }

    //  クリア判定等
    function Check(){
      if(graph.type === "title"){
        //  タイトル画面スライド後の処理
        if(Math.min(Math.abs(vars[2].value-0),Math.abs(vars[2].value-1),Math.abs(vars[2].value-2))<=2/30){
          buttons.next.available = 1;
        }else{
          buttons.next.available = 0;
        }
        DrawAll();
        return 0;
      }
      else if(graph.type === "congrats"){
        //  完全クリア画面スライド後の処理
        if(vars[2].value===0){
          //  タイトル画面または追加ステージに遷移!!!
          let b = vars[2].value-1 > 0;
          level = 0;
          Reset(2);
          vars[2].value = b;
          level = 1;
        }
        DrawAll();
        return 0;
      }
      if(graph.type === "stages")return 0;
      if(graph.type === "levels")return 0;
      if(clear===2)return 0;
      let bool = 1;
      for(let i=0; i<4; i++){
        if(!vars[i].available)continue;
        if(Math.abs(vars[i].value-problems[level].answer[i])>(vars[i].max-vars[i].min)/30){
          bool = 0;
        }
      }
      if(bool)Clear();
    }

    //  クリア後の処理
    async function Clear(){
      for(let i=0; i<4; i++){
        if(vars[i].available)
          vars[i].value = problems[level].answer[i];
      }
      if(clear)return 0;
      Unlock(level+1);
      SaveCookie();
      SetButtons();
      clear = 1;
      await Sleep(50);
      DrawAll();
    }

    //  レベルnの開放
    function Unlock(n){
      cdata.maxlevel = Math.max(cdata.maxlevel,Math.min(n,Object.keys(problems).reduce((a,b)=>Math.max(+a,+b))));
      SetButtons();
      clear = 0;
      DrawAll();
    }

    //  ステージ・レベル選択画面の描画
    function DrawSelect(){
      let b = graph.type==="levels";
      graph.scale = 55;
      vars[0].available = 1;
      vars[0].min = 1;
      vars[0].max = 4;
      vars[0].value = b ? ((level-1)%12)%4+1 : Math.floor((level-1)/12)%4+1;
      vars[0].scale = 1;
      vars[1].available = 1;
      vars[1].min = 1;
      vars[1].max = 3;
      vars[1].value = b ? Math.floor(((level-1)%12)/4)+1 : Math.floor(Math.floor((level-1)/12)/4)+1;
      vars[1].scale = 1;
      vars[2].available = 0;
      vars[3].available = 0;
      SetButtons();
      DrawAll();
    }

    //  設定画面の描画
    function DrawSettings(){
      graph.scale = 148/2;
      vars[0].available = 1;
      vars[0].min = 0;
      vars[0].max = 1;
      vars[0].scale = 1;
      vars[0].value = cdata.analog;
      vars[1].available = 1;
      vars[1].min = 0;
      vars[1].max = 3;
      vars[1].scale = 1;
      vars[1].value = cdata.color;
      vars[2].available = 1;
      vars[2].min = 1;
      vars[2].max = 20;
      vars[2].scale = 0;
      vars[2].value = cdata.weight;
      /*  スマホで綺麗に音が出なかったため，音なしにした!!
      vars[3].available = 1;
      vars[3].min = 0;
      vars[3].max = 1;
      vars[3].scale = 0;
      vars[3].value = cdata.sound;
      */
      SetButtons();
      AdaptSettings();
      DrawAll();
    }

    //  prevボタン押下時の処理
    function Prev(){
      if(graph.type === "title"){
        //  ホームページへ
        location.href = "../index.html"
      }
      else if(graph.type === "settings"){
        let lvl = level;
        level = 0;
        Reset(2);
        level = lvl;
      }
      else if(graph.type === "stages"){
        let lvl = level;
        level = 0;
        Reset(2);
        level = lvl;
      }
      else if(graph.type === "levels"){
        graph.type = "stages";
        DrawSelect();
      }
      else{
        //  任意のレベル
        let lvl = level;
        level = 0;
        Reset(2);
        level = lvl;
        graph.type = "levels";
        clear = 0;
        SetButtons();
        DrawSelect();
      }
    }

    //  resetボタン押下時の処理
    //  問題画面の初期化. 最初の表示にも用いる
    function Reset(b){
      if(b===1){
        //  手動押下時
        if(graph.type === "title"){
          location.reload();
          return 0;
        }
        else if(graph.type === "settings"){
          //  設定の初期化
          cdata.analog = cdata0.analog;
          cdata.color = cdata0.color;
          cdata.weight = cdata0.weight
          DrawSettings();
          return 0;
        }
        else if(graph.type === "stages"){
          DrawSelect();
          return 0;
        }
        else if(graph.type === "levels"){
          DrawSelect();
          return 0;
        }
        else if(graph.type === "settings"){
          DrawSettings();
          return 0;
        }
      }
      //  自動押下時
      //  グラフの設定
      let p = problems[level];
      graph.type = p.type;
      graph.xaxis = p.xaxis;
      graph.yaxis = p.yaxis;
      graph.scale = p.gscale;
      for(let i=0; i<4; i++){
        //  スライダー移動の可視化!!!
        vars[i].available = p.vars[i];
        vars[i].min = p.min[i];
        vars[i].value = p.value[i];
        vars[i].max = p.max[i];
        vars[i].scale = p.vscale[i];
      }
      clear = 0;

      //  ボタンの設定
      SetButtons();

      DrawAll(b===2);
    }

    //  nextボタン押下時の処理
    function Next(){
      if(graph.type === "title"){
        if(Math.abs(vars[2].value-0)<=2/30){
          //  ステージ選択へ
          graph.type = "stages";
          SetButtons();
          DrawSelect();
        }
        else if(Math.abs(vars[2].value-1)<=2/30){
          //  設定画面へ
          graph.type = "settings";
          SetButtons();
          DrawSettings();
        }
        else if(Math.abs(vars[2].value-2)<=2/30){
          //!!
        }
      }
      else if(graph.type === "stages"){
        graph.type = "levels";
        if(vars[0].value-1+(vars[1].value-1)*4!==Math.floor((level-1)/12)){
          level = (vars[0].value-1+(vars[1].value-1)*4)*12+1;
        }
        DrawSelect();
      }
      else if(graph.type === "levels"){
        level = Math.floor((level-1)/12)*12 + vars[0].value-1+(vars[1].value-1)*4 + 1;
        Reset(2);
      }
      else{
        level += 1;
        Reset(2);
      }
    }

    //  b:背景も描画するかどうか
    function DrawAll(b){
      DrawBackground(b);
      DrawControls(b);
      DrawScreen(b);
    }

    function DrawBackground(b){
      ctx.clearRect(0,0,cvs.width,cvs.height)
      if(b){
        btx.fillStyle = "#ccc";
        btx.fillRect(0,0,bvs.width,bvs.height);
        let gra = btx.createLinearGradient(0,0,bvs.width,0);
        gra.addColorStop(0,"#eee");
        gra.addColorStop(1,"#bbb");
        btx.fillStyle = gra;
        btx.fillRect(0,0,bvs.width,bvs.height);
      }
    }

    //  ページが真っ暗になるバグ発生(解決済)
    function DrawScreen(b){
      ctx.save();
      btx.save();

      //  描画範囲の指定
      SetRRPath(ctx,40,40,920,740,20);
      ctx.clip();
      SetRRPath(btx,40,40,920,740,20);
      btx.clip();
      //  スクリーン左上を原点とする
      ctx.translate(40,40);

      //  背景
      if(graph.type==="settings"){
        let lvl = level;
        level = 0;
        DrawScreenBackground(b);
        level = lvl;
      }
      else{
        DrawScreenBackground(b);
      }

      //  グラフ
      if(graph.type==="title"){
        //  タイトル画面
        //  quitはprevボタンで代用できるため，sandbox等に置き換えるべき!!!
        ctx.strokeStyle = graph.colors.main;
        ctx.lineWidth = cdata.weight;
        if(cdata.analog)ctx.shadowBlur = 10;

        //  タイトル画面(改)
        let t = vars[2].value;
        for(let i=0; i<8; i++){
          for(let j=0; j<2; j++){
            ctx.save();
            ctx.translate(35+110*i,120+340*j);
            ctx.scale(80/2,160/2);
            switch(`${j}${i}`){
              case "00":
                //  G
                ctx.beginPath();
                ctx.moveTo(2,0);
                ctx.lineTo(0,0);
                ctx.lineTo(0,2);
                ctx.lineTo(2,2);
                ctx.lineTo(2,1);
                ctx.lineTo(1,1);
                break;
              case "01":
                //  R
                ctx.beginPath();
                ctx.moveTo(0,2);
                ctx.lineTo(0,0);
                ctx.lineTo(2,0);
                ctx.lineTo(2,1);
                ctx.lineTo(0,1);
                ctx.moveTo(1,1);
                ctx.lineTo(2,2);
                break;
              case "02":
                //  A
                ctx.beginPath();
                ctx.moveTo(0,2);
                ctx.lineTo(0,0);
                ctx.lineTo(2,0);
                ctx.lineTo(2,2);
                ctx.moveTo(0,1);
                ctx.lineTo(2,1);
                break;
              case "03":
                //  P
                ctx.beginPath();
                ctx.moveTo(0,2);
                ctx.lineTo(0,0);
                ctx.lineTo(2,0);
                ctx.lineTo(2,1);
                ctx.lineTo(0,1);
                break;
              case "04":
                //  H
                ctx.beginPath();
                ctx.moveTo(0,2);
                ctx.lineTo(0,0);
                ctx.moveTo(2,0);
                ctx.lineTo(2,2);
                ctx.moveTo(0,1);
                ctx.lineTo(2,1);
                break;
              case "05":
                //  _
                ctx.moveTo(0,2);
                ctx.lineTo(2,2);
                break;
              case "06":
                //  M
                ctx.beginPath();
                ctx.moveTo(0,2);
                ctx.lineTo(0,0);
                ctx.lineTo(2,0);
                ctx.lineTo(2,2);
                ctx.moveTo(1,0);
                ctx.lineTo(1,2);
                break;
              case "07":
                //  E
                ctx.beginPath();
                ctx.moveTo(2,0);
                ctx.lineTo(0,0);
                ctx.lineTo(0,2);
                ctx.lineTo(2,2);
                ctx.moveTo(0,1);
                ctx.lineTo(2,1);
                break;

              case "10":
                //  _S_
                ctx.beginPath();
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,2,0,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,0,2));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,2,1,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,1,2));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,2,2,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,2,2));
                ctx.moveTo(Smooth(t,2,0,2),Smooth(t,2,0,2));
                ctx.lineTo(Smooth(t,2,0,2),Smooth(t,2,1,2));
                ctx.moveTo(Smooth(t,0,2,0),Smooth(t,2,1,2));
                ctx.lineTo(Smooth(t,0,2,0),Smooth(t,2,2,2));
                break;
              case "11":
                //  _E_
                ctx.beginPath();
                ctx.moveTo(Smooth(t,2,2,2),Smooth(t,2,0,2));
                ctx.lineTo(Smooth(t,0,0,0),Smooth(t,2,0,2));
                ctx.lineTo(Smooth(t,2,0,2),Smooth(t,2,1,2));
                ctx.lineTo(Smooth(t,0,0,0),Smooth(t,2,2,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,2,2));
                ctx.moveTo(Smooth(t,2,0,2),Smooth(t,2,1,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,1,2));
                break;
              case "12":
                //  PTQ
                ctx.beginPath();
                ctx.moveTo(Smooth(t,0,1,0),Smooth(t,0,0,0));
                ctx.lineTo(Smooth(t,0,1,0),Smooth(t,2,2,2));
                ctx.moveTo(Smooth(t,2,1,2),Smooth(t,0,0,0));
                ctx.lineTo(Smooth(t,2,1,2),Smooth(t,1,2,2));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,0,0,0));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,0,0,0));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,1,0,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,1,0,2));
                ctx.moveTo(Smooth(t,0,1,1),Smooth(t,1,0,1));
                ctx.lineTo(Smooth(t,0,1,2),Smooth(t,2,2,2));
                break;
              case "13":
                //  LTU
                ctx.beginPath();
                ctx.moveTo(Smooth(t,0,1,0),Smooth(t,0,0,0));
                ctx.lineTo(Smooth(t,0,1,0),Smooth(t,2,2,2));
                ctx.moveTo(Smooth(t,0,1,2),Smooth(t,0,0,0));
                ctx.lineTo(Smooth(t,0,1,2),Smooth(t,2,2,2));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,2,0,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,0,2));
                break;
              case "14":
                //  AII
                ctx.beginPath();
                ctx.moveTo(Smooth(t,0,1,1),Smooth(t,0,0,0));
                ctx.lineTo(Smooth(t,0,1,1),Smooth(t,2,2,2));
                ctx.moveTo(Smooth(t,2,1,1),Smooth(t,0,0,0));
                ctx.lineTo(Smooth(t,2,1,1),Smooth(t,2,2,2));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,0,0,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,0,0,2));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,1,2,0));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,1,2,0));
                break;
              case "15":
                //  YNT
                ctx.beginPath();
                ctx.moveTo(Smooth(t,0,0,1),Smooth(t,0,0,0));
                ctx.lineTo(Smooth(t,0,0,1),Smooth(t,1,2,2));
                ctx.moveTo(Smooth(t,2,2,1),Smooth(t,0,0,0));
                ctx.lineTo(Smooth(t,2,2,1),Smooth(t,1,2,2));
                ctx.moveTo(Smooth(t,1,1,1),Smooth(t,1,0,0));
                ctx.lineTo(Smooth(t,1,1,1),Smooth(t,2,2,2));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,1,0,0));
                ctx.lineTo(Smooth(t,1,1,1),Smooth(t,1,0,0));
                ctx.moveTo(Smooth(t,1,1,1),Smooth(t,1,2,0));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,1,2,0));
                break;
              case "16":
                //  _G_
                ctx.beginPath();
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,2,0,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,0,2));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,2,2,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,2,2));
                ctx.moveTo(Smooth(t,1,1,1),Smooth(t,2,1,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,1,2));
                ctx.moveTo(Smooth(t,2,0,2),Smooth(t,2,0,2));
                ctx.lineTo(Smooth(t,2,0,2),Smooth(t,2,2,2));
                ctx.moveTo(Smooth(t,1,2,0),Smooth(t,2,1,2));
                ctx.lineTo(Smooth(t,1,2,0),Smooth(t,2,2,2));
                break;
              case "17":
                //  _S_
                ctx.beginPath();
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,2,0,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,0,2));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,2,1,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,1,2));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,2,2,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,2,2));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,2,0,2));
                ctx.lineTo(Smooth(t,2,0,2),Smooth(t,2,1,2));
                ctx.moveTo(Smooth(t,0,2,0),Smooth(t,2,1,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,2,2));
                break;
            }
            ctx.restore();
            ctx.stroke();
          }
        }

        ctx.shadowBlur = 0;
      }
      else if(graph.type==="settings"){
        //  設定画面
        ctx.fillStyle = graph.colors.main;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = "82px 'Roboto Mono'";
        if(cdata.analog)ctx.shadowBlur = 10;
        ctx.fillText(`DISPLAY - ${cdata.analog?"ANALOG ":"DIGITAL"}`,920/2,148*1);
        ctx.fillText(`COLOR   -   ${["Y / C","C / R","P / O","O / Y"][cdata.color]}`,920/2,148*2);
        ctx.fillText(`WEIGHT  -        `,920/2,148*3);
        ctx.fillText(`                 `,920/2,148*4);

        //  サンプル
        ctx.lineWidth = cdata.weight;
        ctx.strokeStyle = graph.colors.main;
        ctx.beginPath();
        ctx.moveTo(920*.75-160,148*3+50);
        ctx.lineTo(920*.75-  0,148*3-50);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(920*.75+160,148*3+50,cdata.weight,0,Math.PI*2);
        ctx.stroke();
        ctx.strokeStyle = graph.colors.hint;
        ctx.setLineDash([cdata.weight*1.5,cdata.weight*1.5,cdata.weight*4.5,cdata.weight*1.5]);
        ctx.beginPath();
        ctx.moveTo(920*.75+  0,148*3+50);
        ctx.lineTo(920*.75+160,148*3-50);
        ctx.stroke();
        ctx.shadowBlur = 0;
      }
      else if(graph.type==="stages"){
        //  ステージ選択
        //  ボタンの枠
        ctx.lineWidth = cdata.weight*1.5;
        for(let y=0; y<3; y++){
          for(let x=0; x<4; x++){
            ctx.strokeStyle = x+y*4<=Math.ceil(cdata.maxlevel/12)-1 ? graph.colors.main : graph.colors.disabled;
            ctx.fillStyle = x+y*4<=Math.ceil(cdata.maxlevel/12)-1 ? graph.colors.main_ : graph.colors.disabled_;
            ctx.fillRect(50+220*x,70+220*y,160,160);
            if(cdata.analog)ctx.shadowBlur = 10;
            ctx.strokeRect(50+220*x,70+220*y,160,160);
            ctx.shadowBlur = 0;
            if(x+y*4 === vars[0].value-1+(vars[1].value-1)*4){
              //  選択中のボタンは大きくする
              ctx.fillRect(50+220*x,70+220*y,160,160);
              ctx.fillRect(50+220*x,70+220*y,160,160);
              if(cdata.analog)ctx.shadowBlur = 10;
              ctx.strokeRect(50+220*x-10,70+220*y-10,160+20,160+20);
              ctx.shadowBlur = 0;
            }

            //  各ステージのアイコン
            ctx.strokeStyle = x+y*4<=Math.ceil(cdata.maxlevel/12)-1 ? graph.colors.main : graph.colors.disabled;
            DrawIcon(x+y*4,x,y);
          }
        }
      }
      else if(graph.type==="levels"){
        //  レベル選択
        //  ボタンの枠
        ctx.lineWidth = cdata.weight*1.5;
        ctx.font = "120px 'Roboto Mono'";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        for(let y=0; y<3; y++){
          for(let x=0; x<4; x++){
            ctx.strokeStyle = x+y*4<=cdata.maxlevel-Math.floor((level-1)/12)*12-1 ? graph.colors.main : graph.colors.disabled;
            ctx.fillStyle = x+y*4<=cdata.maxlevel-Math.floor((level-1)/12)*12-1 ? graph.colors.main_ : graph.colors.disabled_;
            ctx.fillRect(50+220*x,70+220*y,160,160);
            if(cdata.analog)ctx.shadowBlur = 10;
            ctx.strokeRect(50+220*x,70+220*y,160,160);
            ctx.shadowBlur = 0;
            if(x+y*4 === vars[0].value-1+(vars[1].value-1)*4){
              //  選択中のボタンは大きくする
              ctx.fillRect(50+220*x,70+220*y,160,160);
              ctx.fillRect(50+220*x,70+220*y,160,160);
              if(cdata.analog)ctx.shadowBlur = 10;
              ctx.strokeRect(50+220*x-10,70+220*y-10,160+20,160+20);
              ctx.shadowBlur = 0;
            }
            //  各ステージのアイコン
            ctx.strokeStyle = x+y*4<=Math.ceil(cdata.maxlevel/12)-1 ? graph.colors.main_ : graph.colors.disabled_;
            DrawIcon(Math.floor((level-1)/12),x,y);
            //  レベル番号
            if(cdata.analog)ctx.shadowBlur = 10;
            ctx.fillStyle = x+y*4<=cdata.maxlevel-Math.floor((level-1)/12)*12-1 ? graph.colors.main : graph.colors.disabled;
            ctx.fillText((x+y*4+1).toString(16).toUpperCase(),130+220*x,150+220*y);
            ctx.shadowBlur = 0;
          }
        }
      }
      else if(graph.type==="congrats"){
        //  完全クリア画面
        ctx.strokeStyle = graph.colors.main;
        ctx.lineWidth = cdata.weight;
        if(cdata.analog)ctx.shadowBlur = 10;

        //  タイトル画面(改)
        let t = vars[2].value;
        for(let i=0; i<8; i++){
          for(let j=0; j<2; j++){
            ctx.save();
            ctx.translate(35+110*i,120+340*j);
            ctx.scale(80/2,160/2);
            ctx.beginPath();
            switch(`${j}${i}`){
              case "00":
                //  GG_
                ctx.moveTo(Smooth(t,2,2,2),Smooth(t,0,0,2));
                ctx.lineTo(Smooth(t,0,0,2),Smooth(t,0,0,2));
                ctx.lineTo(Smooth(t,0,0,2),Smooth(t,2,2,2));
                ctx.lineTo(Smooth(t,2,2,0),Smooth(t,2,2,2));
                ctx.lineTo(Smooth(t,2,2,0),Smooth(t,1,1,2));
                ctx.lineTo(Smooth(t,1,1,0),Smooth(t,1,1,2));
                break;
              case "01":
                //  RR_
                ctx.moveTo(Smooth(t,0,0,2),Smooth(t,2,2,2));
                ctx.lineTo(Smooth(t,0,0,0),Smooth(t,0,0,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,0,0,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,1,1,2));
                ctx.lineTo(Smooth(t,0,0,1),Smooth(t,1,1,2));
                ctx.moveTo(Smooth(t,1,1,2),Smooth(t,1,1,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,2,2));
                break;
              case "02":
                //  AAG
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,0,0,0));
                ctx.lineTo(Smooth(t,0,0,0),Smooth(t,2,2,2));
                ctx.moveTo(Smooth(t,2,2,2),Smooth(t,1,1,1));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,2,2));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,0,0,0));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,0,0,0));
                ctx.moveTo(Smooth(t,2,2,1),Smooth(t,0,0,1));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,1,1,1));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,1,1,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,1,1,2));
                break;
              case "03":
                //  PPA
                ctx.moveTo(0,2);
                ctx.lineTo(0,0);
                ctx.lineTo(2,0);
                ctx.lineTo(2,1);
                ctx.lineTo(0,1);
                ctx.moveTo(Smooth(t,0,0,2),Smooth(t,1,1,1));
                ctx.lineTo(Smooth(t,0,0,2),Smooth(t,2,2,2));
                break;
              case "04":
                //  HHM
                ctx.moveTo(0,2);
                ctx.lineTo(0,0);
                ctx.moveTo(2,0);
                ctx.lineTo(2,2);
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,1,1,0));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,1,1,0));
                ctx.moveTo(Smooth(t,1,1,1),Smooth(t,1,1,0));
                ctx.lineTo(Smooth(t,1,1,1),Smooth(t,1,1,2));
                break;
              case "05":
                //  __E
                ctx.moveTo(Smooth(t,2,2,2),Smooth(t,2,2,0));
                ctx.lineTo(Smooth(t,0,0,0),Smooth(t,2,2,0));
                ctx.lineTo(Smooth(t,0,0,0),Smooth(t,2,2,1));
                ctx.lineTo(Smooth(t,0,0,0),Smooth(t,2,2,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,2,2));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,2,2,1));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,2,1));
                break;
              case "06":
                //  MM_
                ctx.moveTo(0,2);
                ctx.lineTo(0,Smooth(t,0,0,2));
                ctx.lineTo(2,Smooth(t,0,0,2));
                ctx.lineTo(2,2);
                ctx.moveTo(1,Smooth(t,0,0,2));
                ctx.lineTo(1,2);
                break;
              case "07":
                //  EE_
                ctx.moveTo(2,Smooth(t,0,0,2));
                ctx.lineTo(Smooth(t,0,0,2),Smooth(t,0,0,2));
                ctx.lineTo(0,2);
                ctx.lineTo(2,2);
                ctx.moveTo(Smooth(t,0,0,1),Smooth(t,1,1,2));
                ctx.lineTo(2,Smooth(t,1,1,2));
                break;

              case "10":
                //  _BC
                ctx.moveTo(Smooth(t,1,1,2),Smooth(t,2,0,0));
                ctx.lineTo(Smooth(t,0,0,0),Smooth(t,2,0,0));
                ctx.lineTo(Smooth(t,0,0,0),Smooth(t,2,2,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,2,2));
                ctx.moveTo(Smooth(t,2,2,0),Smooth(t,2,2,2));
                ctx.lineTo(Smooth(t,2,2,0),Smooth(t,2,1,1));
                ctx.lineTo(Smooth(t,0,0,0),Smooth(t,2,1,1));
                ctx.moveTo(Smooth(t,1,1,0),Smooth(t,2,1,1));
                ctx.lineTo(Smooth(t,1,1,0),Smooth(t,2,0,0));
                break;
              case "11":
                //  _YO
                ctx.moveTo(Smooth(t,2,2,2),Smooth(t,2,0,0));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,1,2));
                ctx.lineTo(Smooth(t,0,0,0),Smooth(t,2,1,2));
                ctx.lineTo(Smooth(t,0,0,0),Smooth(t,2,0,0));
                ctx.moveTo(Smooth(t,1,1,1),Smooth(t,2,1,2));
                ctx.lineTo(Smooth(t,1,1,1),Smooth(t,2,2,2));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,2,1,0));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,1,0));
                break;
              case "12":
                //  P_M
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,2,2,2));
                ctx.lineTo(Smooth(t,0,0,0),Smooth(t,0,2,0));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,0,2,0));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,1,2,2));
                ctx.moveTo(Smooth(t,0,1,1),Smooth(t,1,2,0));
                ctx.lineTo(Smooth(t,2,1,1),Smooth(t,1,2,2));
                break;
              case "13":
                //  LTP
                ctx.moveTo(Smooth(t,0,1,0),Smooth(t,0,0,0));
                ctx.lineTo(Smooth(t,0,1,0),Smooth(t,2,2,2));
                ctx.moveTo(Smooth(t,0,1,2),Smooth(t,0,0,0));
                ctx.lineTo(Smooth(t,0,1,2),Smooth(t,1,1,1));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,2,0,0));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,0,0));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,2,0,1));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,0,1));
                break;
              case "14":
                //  AOL
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,0,0,0));
                ctx.lineTo(Smooth(t,0,0,0),Smooth(t,2,2,2));
                ctx.moveTo(Smooth(t,2,2,0),Smooth(t,0,0,0));
                ctx.lineTo(Smooth(t,2,2,0),Smooth(t,2,2,2));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,0,0,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,0,0,2));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,1,2,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,1,2,2));
                break;
              case "15":
                //  YME
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,0,0,2));
                ctx.lineTo(Smooth(t,0,0,2),Smooth(t,1,2,2));
                ctx.moveTo(Smooth(t,2,2,0),Smooth(t,0,0,0));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,1,2,0));
                ctx.moveTo(Smooth(t,1,1,0),Smooth(t,1,0,1));
                ctx.lineTo(Smooth(t,1,1,2),Smooth(t,2,2,1));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,1,0,2));
                ctx.lineTo(Smooth(t,1,1,0),Smooth(t,1,0,1));
                ctx.moveTo(Smooth(t,1,1,0),Smooth(t,1,0,1));
                ctx.lineTo(Smooth(t,2,2,0),Smooth(t,1,0,0));
                break;
              case "16":
                //  _OT
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,2,0,0));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,0,0));
                ctx.moveTo(Smooth(t,0,0,1),Smooth(t,2,0,0));
                ctx.lineTo(Smooth(t,0,0,1),Smooth(t,2,2,2));
                ctx.lineTo(Smooth(t,2,2,1),Smooth(t,2,2,2));
                ctx.lineTo(Smooth(t,2,2,1),Smooth(t,2,0,0));
                break;
              case "17":
                //  _QE
                ctx.moveTo(Smooth(t,2,2,2),Smooth(t,2,0,0));
                ctx.lineTo(Smooth(t,0,0,0),Smooth(t,2,0,0));
                ctx.lineTo(Smooth(t,0,0,0),Smooth(t,2,2,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,2,2));
                ctx.moveTo(Smooth(t,1,1,0),Smooth(t,2,1,1));
                ctx.lineTo(Smooth(t,2,2,1),Smooth(t,2,2,1));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,0,1));
                break;
            }
            ctx.restore();
            ctx.stroke();
          }
        }

        ctx.shadowBlur = 0;
      }
      else{
        //  陽関数，極座標，媒介変数，陰関数
        let p = problems[level];

        if(cdata.analog)ctx.shadowBlur = 10;
        if(b){
          if(!p.hide)//  ヒント部分
            DrawScreenGraph(
              graph.colors.main,cdata.weight/2,[cdata.weight*1.5,cdata.weight*1.5],
              graph.type==="implicit"
              ? (x,y)=>p.func(x,y,p.answer[0],p.answer[1],p.answer[2],p.answer[3])
              : (x)=>p.func(x,p.answer[0],p.answer[1],p.answer[2],p.answer[3]),p.range&&[p.range[2],p.range[3]]
            );
          if(p.tangent)//  接線
            DrawScreenGraph(
              graph.colors.hint,cdata.weight/2,[cdata.weight*1.5,cdata.weight*1.5,
              cdata.weight*4.5,cdata.weight*1.5],
              graph.type==="implicit"
              ? (x,y)=>p.funcTangent(x,y,p.answer[0],p.answer[1],p.answer[2],p.answer[3])
              : (x)=>p.funcTangent(x,p.answer[0],p.answer[1],p.answer[2],p.answer[3])
            );
          if(p.tangent2)//  接線
            DrawScreenGraph(
              graph.colors.hint,cdata.weight/2,[cdata.weight*1.5,cdata.weight*1.5,cdata.weight*4.5,cdata.weight*1.5],
              graph.type==="implicit"
              ? (x,y)=>p.funcTangent2(x,y,p.answer[0],p.answer[1],p.answer[2],p.answer[3])
              : (x)=>p.funcTangent2(x,p.answer[0],p.answer[1],p.answer[2],p.answer[3])
            );
        }
        if(1)
          //  可動グラフ部分
          DrawScreenGraph(
            graph.colors.main,cdata.weight,[],
            graph.type==="implicit"
            ? (x,y)=>p.func(x,y,vars[0].value,vars[1].value,vars[2].value,vars[3].value)
            : (x)=>p.func(x,vars[0].value,vars[1].value,vars[2].value,vars[3].value),p.range&&[p.range[0],p.range[1]]
          );

        //  通過する点
        if(p.points){
          if(graph.type == "explicit"){
            let x,y,X,Y;
            let sx = p.skewx || 0;
            let sy = p.skewy || 0;
            ctx.lineWidth = cdata.weight;
            ctx.strokeStyle = graph.colors.main;
            for(let i=0; i<problems[level].points.length; i++){
              x = p.points[i];
              y = p.func(x,problems[level].answer[0],problems[level].answer[1],problems[level].answer[2],problems[level].answer[3]);
              x = x*graph.scale;
              y = -y*graph.scale;
              X = x + sx*y;
              Y = y + sy*x;
              ctx.beginPath();
              ctx.arc(p.yaxis+X,p.xaxis+Y,cdata.weight,0,Math.PI*2);
              ctx.stroke();
            }
          }
          else if(graph.type == "polar"){
            let X,Y;
            let sx = p.skewx || 0;
            let sy = p.skewy || 0;
            ctx.lineWidth = cdata.weight;
            ctx.strokeStyle = graph.colors.main;
            for(let i=0; i<problems[level].points.length; i++){
              x = p.points[i];
              y = p.func(x,problems[level].answer[0],problems[level].answer[1],problems[level].answer[2],problems[level].answer[3]);
              x = x*graph.scale;
              y = -y*graph.scale;
              X = x + sx*y;
              Y = y + sy*x;
              ctx.beginPath();
              ctx.arc(p.yaxis+X,p.xaxis+Y,cdata.weight,0,Math.PI*2);
              ctx.stroke();
            }
          }
        }


        //  式の表示
        DrawScreenFuncStr();
      }

      //  クリアメッセージ
      if(clear === 1){
        ctx.fillStyle = "#000000c0";
        ctx.fillRect(-10,-10,940,760);
        let txt = "LEVEL ";
        txt += `${(Math.floor((level-1)/12)+1).toString(16).toUpperCase()}-`;
        txt += `${((level-1)%12+1).toString(16).toUpperCase()}`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = graph.colors.message_;
        ctx.strokeStyle = graph.colors.message;
        ctx.lineWidth = 5;
        ctx.font = "130px 'Roboto Mono'";
        ctx.fillText(`${txt}`,460,200);
        if(cdata.analog)ctx.shadowBlur = 10;
        ctx.strokeText(`${txt}`,460,200);
        ctx.font = "240px 'Roboto Mono'";
        ctx.strokeText(`CLEAR!`,460,500);
        ctx.shadowBlur = 0;
        ctx.fillText(`CLEAR!`,460,500);
      }


      //  枠
      ctx.strokeStyle = "#333";
      ctx.setLineDash([]);
      ctx.lineWidth = 10;
      SetRRPath(ctx,0,0,920,740,20);
      ctx.stroke();
      ctx.restore();
      btx.restore();
    }

    //  各ステージのアイコンの描画
    function DrawIcon(i,x,y){
      switch(i){
        case 0:
          //  1:礎
          ctx.beginPath();
          ctx.moveTo(130+220*x-40,150+220*y-40);
          ctx.lineTo(130+220*x+0,150+220*y+40);
          ctx.lineTo(130+220*x+40,150+220*y-40);
          ctx.stroke();
          break;
        case 1:
          //  2:三
          ctx.beginPath();
          ctx.moveTo(130+220*x-40,150+220*y+40);
          ctx.lineTo(130+220*x+40,150+220*y+40);
          ctx.lineTo(130+220*x+40,150+220*y-40);
          ctx.lineTo(130+220*x-40,150+220*y+40);
          ctx.stroke();
          break;
        case 2:
          //  3:絶
          ctx.beginPath();
          ctx.moveTo(130+220*x-40,150+220*y+40);
          ctx.lineTo(130+220*x-40,150+220*y-40);
          ctx.moveTo(130+220*x+40,150+220*y+40);
          ctx.lineTo(130+220*x+40,150+220*y-40);
          ctx.stroke();
          break;
        case 3:
          //  4:指
          ctx.beginPath();
          ctx.moveTo(130+220*x-40,150+220*y+0);
          ctx.lineTo(130+220*x+0,150+220*y-40);
          ctx.lineTo(130+220*x+40,150+220*y+0);
          ctx.stroke();
          break;
        case 4:
          //  5:高
          ctx.beginPath();
          ctx.moveTo(130+220*x-40,150+220*y+40);
          ctx.lineTo(130+220*x-40,150+220*y+0);
          ctx.lineTo(130+220*x+40,150+220*y+0);
          ctx.lineTo(130+220*x+40,150+220*y-40);
          ctx.stroke();
          break;
        case 5:
          //  6:分
          ctx.beginPath();
          ctx.moveTo(130+220*x-40,150+220*y+0);
          ctx.lineTo(130+220*x+0,150+220*y+40);
          ctx.moveTo(130+220*x+0,150+220*y-40);
          ctx.lineTo(130+220*x+40,150+220*y+0);
          ctx.stroke();
          break;
        case 6:
          //  7:断
          ctx.beginPath();
          ctx.moveTo(130+220*x-40,150+220*y+40);
          ctx.lineTo(130+220*x+0,150+220*y+40);
          ctx.moveTo(130+220*x+0,150+220*y-40);
          ctx.lineTo(130+220*x+40,150+220*y-40);
          ctx.stroke();
          break;
        case 7:
          //  8:斜
          ctx.beginPath();
          ctx.moveTo(130+220*x-40,150+220*y+40);
          ctx.lineTo(130+220*x+0,150+220*y+40);
          ctx.lineTo(130+220*x+40,150+220*y-40);
          ctx.lineTo(130+220*x+0,150+220*y-40);
          ctx.lineTo(130+220*x-40,150+220*y+40);
          ctx.stroke();
          break;
        case 8:
          //  9:極
          ctx.beginPath();
          ctx.moveTo(130+220*x+40,150+220*y+40);
          ctx.lineTo(130+220*x-40,150+220*y+40);
          ctx.lineTo(130+220*x+0,150+220*y-40);
          ctx.stroke();
          break;
        case 9:
          //  10:媒
          ctx.beginPath();
          ctx.moveTo(130+220*x+40,150+220*y-40);
          ctx.lineTo(130+220*x-40,150+220*y+40);
          ctx.lineTo(130+220*x-40,150+220*y-40);
          ctx.lineTo(130+220*x+40,150+220*y+40);
          ctx.lineTo(130+220*x+40,150+220*y-40);
          ctx.stroke();
          break;
        case 10:
          //  11:陰
          ctx.beginPath();
          ctx.moveTo(130+220*x+40,150+220*y+0);
          ctx.lineTo(130+220*x+0,150+220*y-40);
          ctx.lineTo(130+220*x-40,150+220*y+0);
          ctx.lineTo(130+220*x+0,150+220*y+40);
          ctx.lineTo(130+220*x+40,150+220*y+0);
          ctx.stroke();
          break;
        case 11:
          //  12:陰+
          ctx.beginPath();
          ctx.moveTo(130+220*x+40,150+220*y+0);
          ctx.lineTo(130+220*x+0,150+220*y-40);
          ctx.lineTo(130+220*x-40,150+220*y+0);
          ctx.lineTo(130+220*x+0,150+220*y+40);
          ctx.lineTo(130+220*x+40,150+220*y+0);
          ctx.moveTo(130+220*x+40,150+220*y+40);
          ctx.lineTo(130+220*x+40,150+220*y-40);
          ctx.lineTo(130+220*x-40,150+220*y-40);
          ctx.lineTo(130+220*x-40,150+220*y+40);
          ctx.lineTo(130+220*x+40,150+220*y+40);
          ctx.stroke();
          break;
      }
    }

    function SkewGraph(r){
      let p = problems[level];
      let sx = p.skewx || 0;
      let sy = p.skewy || 0;
      let x0 = graph.yaxis;
      let y0 = graph.xaxis;
      if(r){
        ctx.transform(1/(1-sx*sy),-sy/(1-sx*sy),-sx/(1-sx*sy),1/(1-sx*sy),0,0);
        ctx.translate(-x0,-y0);
        btx.transform(1/(1-sx*sy),-sy/(1-sx*sy),-sx/(1-sx*sy),1/(1-sx*sy),0,0);
        btx.translate(-x0,-y0);
      }
      else{
        ctx.translate(x0,y0);
        ctx.transform(1,sy,sx,1,0,0);
        btx.translate(x0,y0);
        btx.transform(1,sy,sx,1,0,0);
      }
    }

    function DrawScreenBackground(b){
      if(b){
        btx.translate(40,40);
        if(cdata.analog){
          let gra = btx.createRadialGradient(460,370,0,460,370,1000);
          gra.addColorStop(0.0,"#246347");
          gra.addColorStop(0.7,"#133828");
          gra.addColorStop(1.0,"#091c14");
          btx.fillStyle = gra;
          btx.fillRect(-10,-10,940,760);
        }
        else{
          btx.fillStyle = "#000";
          btx.fillRect(-10,-10,940,760);
        }

        //  グリッド
        let sx = problems[level].skewx || 0;
        let sy = problems[level].skewy || 0;
        let x0 = graph.yaxis;
        let y0 = graph.xaxis;
        btx.strokeStyle = cdata.analog ? "#333" : "#444";
        if(graph.type!=="polar"){
          //  縦
          for(
            let i=Math.ceil((-x0-Math.max(sx*(-y0),sx*(740-y0)))/(1-sx*sy)/graph.scale);
            i<=Math.floor((920-x0-Math.min(sx*(-y0),sx*(740-y0)))/(1-sx*sy)/graph.scale);
            i++
          )
          {
            btx.lineWidth = i%5 ? 4 : 6;
            SkewGraph();
            btx.beginPath();
            btx.moveTo(i*graph.scale,-(y0-Math.min(sy*(-x0),sy*(920-x0)))/(1-sx*sy));
            btx.lineTo(i*graph.scale,-(y0-740-Math.max(sy*(-x0),sy*(920-x0)))/(1-sx*sy));
            SkewGraph(1);
            btx.stroke();
          }
          //  横
          for(
            let i=Math.ceil(-(y0-Math.min(sy*(-x0),sy*(920-x0)))/(1-sx*sy)/graph.scale);
            i<=Math.floor(-(y0-740-Math.max(sy*(-x0),sy*(920-x0)))/(1-sx*sy)/graph.scale);
            i++
          )
          {
            btx.lineWidth = i%5 ? 4 : 6;
            SkewGraph();
            btx.beginPath();
            btx.moveTo((-x0-Math.max(sx*(-y0),sx*(740-y0)))/(1-sx*sy),i*graph.scale);
            btx.lineTo((920-x0-Math.min(sx*(-y0),sx*(740-y0)))/(1-sx*sy),i*graph.scale);
            SkewGraph(1);
            btx.stroke();
          }
        }
        else if(graph.type==="polar"){
          //  縦
          btx.beginPath();
          for(let i=0; i<6; i++){
            btx.lineWidth = 4;
            btx.moveTo(x0+1200*Math.cos(Math.PI/6*i),y0-1200*Math.sin(Math.PI/6*i));
            btx.lineTo(x0-1200*Math.cos(Math.PI/6*i),y0+1200*Math.sin(Math.PI/6*i));
          }
          btx.stroke();
          //  横
          for(let i=1; i<=1200/graph.scale; i++){
            btx.lineWidth = i%5 ? 4 : 6;
            btx.beginPath();
            btx.arc(x0,y0,graph.scale*i,0,Math.PI*2);
            btx.stroke();
          }
        }
        //  軸
        btx.lineWidth = 8;
        btx.strokeStyle = cdata.analog ? "#333" : "#777";
        SkewGraph();
        btx.beginPath();
        btx.moveTo(0,-(y0-Math.min(sy*(-x0),sy*(920-x0)))/(1-sx*sy));
        btx.lineTo(0,-(y0-740-Math.max(sy*(-x0),sy*(920-x0)))/(1-sx*sy));
        SkewGraph(1);
        btx.stroke();
        SkewGraph();
        btx.beginPath();
        btx.moveTo((-x0-Math.max(sx*(-y0),sx*(740-y0)))/(1-sx*sy),0);
        btx.lineTo((920-x0-Math.min(sx*(-y0),sx*(740-y0)))/(1-sx*sy),0);
        SkewGraph(1);
        btx.stroke();
      }


      //  レベルの表示
      if(graph.type.match(/explicit|polar|parameter|implicit/)){
        ctx.fillStyle = cdata.analog ? "#222" : "#888";
        ctx.textAlign = "left";
        ctx.textBaseline = "bottom";
        ctx.font = "70px 'Roboto Mono'";
        ctx.fillText(
          `${(Math.floor((level-1)/12)+1).toString(16).toUpperCase()}-${((level-1)%12+1).toString(16).toUpperCase()}`,
          10,740-10
        );
      }
    }

    //  最初の描画時にフォントがおかしくなる!!!
    function DrawScreenFuncStr(){
      let bgs;
      if(cdata.analog){
        bgs = ctx.createRadialGradient(460-40,370-40,0,460-40,370-40,1000);//  ずれる可能性あり．未確認!!!
        bgs.addColorStop(0.0,"#246347");
        bgs.addColorStop(0.7,"#133828");
        bgs.addColorStop(1.0,"#091c14");
      }
      else{
        bgs = "#000";
      }
      //  影を落とす!!
      let strs0,strs1,chars,x0,w0,w1,w;
      let p = problems[level];
      x = 40;
      ctx.strokeStyle = graph.colors.main;
      ctx.shadowBlur = 0;
      ctx.setLineDash([]);
      ctx.lineWidth = 5;
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      ctx.scale(2/3,2/3);
      if(p.funcstr.match(/F/)){//  分数を含むとき
        strs0 = p.funcstr.match(/F\{[^\}]*\}\{[^\}]*\}|[^F]+/g);//  分数部分または一般部分
        ctx.fillStyle = bgs;
        ctx.fillRect(20,20,40,170);
        for(let i=0; i<strs0.length; i++){
          if(strs0[i].match(/F/)){//  分数部分
            //  この行の所為で一日費やした^^  strs1 = strs0[i].match(/(?<={)[^\}]*(?=})/g);//  [分子,分母]
            //  strs0[i]は"F{...}{...}"の形だから，splitで分ける．
            strs1 = strs0[i].replace(/^F{|}$/g,"").split("}{");//  [分子,分母]
            ctx.font = "60px 'Roboto Mono'";
            w0 = ctx.measureText(strs1[0].replace(/\^.|#./g,"")).width;
            w1 = ctx.measureText(strs1[1].replace(/\^.|#./g,"")).width;
            ctx.font = "75px 'Roboto Mono'";
            w0 += ctx.measureText(strs1[0].replace(/[^#]/g,"")).width;
            w1 += ctx.measureText(strs1[1].replace(/[^#]/g,"")).width;
            ctx.font = "40px 'Roboto Mono'";
            w0 += ctx.measureText(strs1[0].replace(/[^^]/g,"")).width;
            w1 += ctx.measureText(strs1[1].replace(/[^^]/g,"")).width;
            w = Math.max(w0,w1);
            ctx.fillStyle = bgs;
            ctx.fillRect(x,20,w+40,170);
            x0 = x+20;
            ctx.beginPath();
            ctx.moveTo(x+10,100);
            ctx.lineTo(x+w+30,100);
            ctx.stroke();
            //  分子の描画
            x = x0+(w-w0)/2;
            chars = strs1[0].match(/[\^\#]?./g);
            for(let j=0; j<chars.length; j++){
              if(chars[j].match(/\^/)){
                chars[j] = chars[j].replace("^","");
                y = 60;
                ctx.font = "40px 'Roboto Mono'";
              }else if(chars[j].match(/\#/)){
                chars[j] = chars[j].replace("#","");
                y = 65;
                ctx.font = "75px 'Roboto Mono'";
              }else{
                y = 70;
                ctx.font = "60px 'Roboto Mono'";
              }
              ctx.fillStyle = graph.colors.main;
              if(cdata.analog)ctx.shadowBlur = 10;
              ctx.fillText(chars[j],x,y);
              ctx.shadowBlur = 0;
              x += ctx.measureText(chars[j]).width;
            }
            //  分母の描画
            x = x0+(w-w1)/2;
            chars = strs1[1].match(/[\^\#]?./g);
            for(let j=0; j<chars.length; j++){
              if(chars[j].match(/\^/)){
                chars[j] = chars[j].replace("^","");
                y = 60+70;
                ctx.font = "40px 'Roboto Mono'";
              }else if(chars[j].match(/\#/)){
                chars[j] = chars[j].replace("#","");
                y = 65+70;
                ctx.font = "75px 'Roboto Mono'";
              }else{
                y = 70+70;
                ctx.font = "60px 'Roboto Mono'";
              }
              ctx.fillStyle = graph.colors.main;
              if(cdata.analog)ctx.shadowBlur = 10;
              ctx.fillText(chars[j],x,y);
              ctx.shadowBlur = 0;
              x += ctx.measureText(chars[j]).width;
            }
            x = x0+w+20;

          }
          else{//  一般部分
            chars = strs0[i].match(/[\^\#\$]?./g);
            ctx.font = "60px 'Roboto Mono'";
            w = ctx.measureText("|").width;//  普通のフォントの横幅
            for(let j=0; j<chars.length; j++){
              if(chars[j].match(/\^/)){
                chars[j] = chars[j].replace("^","");
                y = 60+35;
                ctx.font = "40px 'Roboto Mono'";//  一回り小さい
              }else if(chars[j].match(/\#/)){
                chars[j] = chars[j].replace("#","");
                y = 65+35;
                ctx.font = "75px 'Roboto Mono'";//  大きめ
              }else if(chars[j].match(/\$/)){
                chars[j] = chars[j].replace("$","");
                y = 65+35;
                ctx.font = "150px 'Roboto Mono'";//  一回り大きい
              }else{
                y = 70+35;
                ctx.font = "60px 'Roboto Mono'";//  普通
              }
              ctx.fillStyle = bgs;
              ctx.fillRect(x,20,ctx.measureText(chars[j]).width,170);
              ctx.fillStyle = graph.colors.main;
              if(cdata.analog)ctx.shadowBlur = 10;
              ctx.fillText(chars[j],x,y,w);
              ctx.shadowBlur = 0;
              x += Math.min(ctx.measureText(chars[j]).width,w);
            }
          }
        }
        ctx.fillStyle = bgs;
        ctx.fillRect(x,20,20,170);
        if(cdata.analog)ctx.shadowBlur = 10;
        ctx.strokeRect(20,20,x,170);
        ctx.shadowBlur = 0;
        ctx.fillStyle = graph.colors.main_;
        ctx.fillRect(20,20,x,170);
      }
      else if(p.funcstr.match(/P/)){//  媒介変数
        strs0 = p.funcstr.match(/P\{[^\}]*\}\{[^\}]*\}|[^P]+/g);//  上下の式または条件式
        strs0.unshift("${");//  おっきい括弧
        ctx.fillStyle = bgs;
        ctx.fillRect(20,20,40,170);
        for(let i=0; i<strs0.length; i++){
          if(strs0[i].match(/P/)){//  上下の式部分
            strs1 = strs0[i].replace(/^P{|}$/g,"").split("}{");//  [上式,下式]
            ctx.font = "60px 'Roboto Mono'";
            w0 = ctx.measureText(strs1[0].replace(/\^.|#./g,"")).width;
            w1 = ctx.measureText(strs1[1].replace(/\^.|#./g,"")).width;
            ctx.font = "75px 'Roboto Mono'";
            w0 += ctx.measureText(strs1[0].replace(/[^#]/g,"")).width;
            w1 += ctx.measureText(strs1[1].replace(/[^#]/g,"")).width;
            ctx.font = "40px 'Roboto Mono'";
            w0 += ctx.measureText(strs1[0].replace(/[^^]/g,"")).width;
            w1 += ctx.measureText(strs1[1].replace(/[^^]/g,"")).width;
            w = Math.max(w0,w1);
            ctx.fillStyle = bgs;
            ctx.fillRect(x,20,w+40,170);
            x0 = x+20;
            //  上式の描画
            x = x0;
            chars = strs1[0].match(/[\^\#]?./g);
            for(let j=0; j<chars.length; j++){
              if(chars[j].match(/\^/)){
                chars[j] = chars[j].replace("^","");
                y = 60;
                ctx.font = "40px 'Roboto Mono'";
              }else if(chars[j].match(/\#/)){
                chars[j] = chars[j].replace("#","");
                y = 65;
                ctx.font = "75px 'Roboto Mono'";
              }else{
                y = 70;
                ctx.font = "60px 'Roboto Mono'";
              }
              ctx.fillStyle = graph.colors.main;
              if(cdata.analog)ctx.shadowBlur = 10;
              ctx.fillText(chars[j],x,y);
              ctx.shadowBlur = 0;
              x += ctx.measureText(chars[j]).width;
            }
            //  下式の描画
            x = x0;
            chars = strs1[1].match(/[\^\#]?./g);
            for(let j=0; j<chars.length; j++){
              if(chars[j].match(/\^/)){
                chars[j] = chars[j].replace("^","");
                y = 60+70;
                ctx.font = "40px 'Roboto Mono'";
              }else if(chars[j].match(/\#/)){
                chars[j] = chars[j].replace("#","");
                y = 65+70;
                ctx.font = "75px 'Roboto Mono'";
              }else{
                y = 70+70;
                ctx.font = "60px 'Roboto Mono'";
              }
              ctx.fillStyle = graph.colors.main;
              if(cdata.analog)ctx.shadowBlur = 10;
              ctx.fillText(chars[j],x,y);
              ctx.shadowBlur = 0;
              x += ctx.measureText(chars[j]).width;
            }
            x = x0+w+20;

          }
          else{//  一般部分
            chars = strs0[i].match(/[\^\#\$]?./g);
            ctx.font = "60px 'Roboto Mono'";
            w = ctx.measureText("|").width;//  普通のフォントの横幅
            for(let j=0; j<chars.length; j++){
              if(chars[j].match(/\^/)){
                chars[j] = chars[j].replace("^","");
                y = 60+35;
                ctx.font = "40px 'Roboto Mono'";//  一回り小さい
              }else if(chars[j].match(/\#/)){
                chars[j] = chars[j].replace("#","");
                y = 65+35;
                ctx.font = "75px 'Roboto Mono'";//  大きめ
              }else if(chars[j].match(/\$/)){
                chars[j] = chars[j].replace("$","");
                y = 65+35;
                ctx.font = "150px 'Roboto Mono'";//  一回り大きい
              }else{
                y = 70+35;
                ctx.font = "60px 'Roboto Mono'";//  普通
              }
              ctx.fillStyle = bgs;
              ctx.fillRect(x,20,ctx.measureText(chars[j]).width,170);
              ctx.fillStyle = graph.colors.main;
              if(cdata.analog)ctx.shadowBlur = 10;
              ctx.fillText(chars[j],x,y,w);
              ctx.shadowBlur = 0;
              x += Math.min(ctx.measureText(chars[j]).width,w);
            }
          }
        }
        ctx.fillStyle = bgs;
        ctx.fillRect(x,20,20,170);
        if(cdata.analog)ctx.shadowBlur = 10;
        ctx.strokeRect(20,20,x,170);
        ctx.shadowBlur = 0;
        ctx.fillStyle = graph.colors.main_;
        ctx.fillRect(20,20,x,170);
      }
      else{//  分数を含まないとき
        ctx.fillStyle = bgs;
        ctx.fillRect(20,20,40,100);
        chars = p.funcstr.match(/[\^\#]?./g);
        for(let i=0; i<chars.length; i++){
          if(chars[i].match(/\^/)){
            chars[i] = chars[i].replace("^","");
            y = 60;
            ctx.font = "40px 'Roboto Mono'";
          }else if(chars[i].match(/\#/)){
            chars[i] = chars[i].replace("#","");
            y = 65;
            ctx.font = "75px 'Roboto Mono'";
          }else{
            y = 70;
            ctx.font = "60px 'Roboto Mono'";
          }
          ctx.fillStyle = bgs;
          ctx.fillRect(x,20,ctx.measureText(chars[i]).width,100);
          ctx.fillStyle = graph.colors.main;
          if(cdata.analog)ctx.shadowBlur = 10;
          ctx.fillText(chars[i],x,y);
          ctx.shadowBlur = 0;
          x += ctx.measureText(chars[i]).width;
        }
        ctx.fillStyle = bgs;
        ctx.fillRect(x,20,20,100);
        if(cdata.analog)ctx.shadowBlur = 10;
        ctx.strokeRect(20,20,x,100);
        ctx.shadowBlur = 0;
        ctx.fillStyle = graph.colors.main_;
        ctx.fillRect(20,20,x,100);
      }
      ctx.scale(3/2,3/2);
    }

    function DrawScreenGraph(s,w,ld,f,r){
      let d;
      let context = ld.length ? btx : ctx;
      let x,y;
      let sx = problems[level].skewx || 0;
      let sy = problems[level].skewy || 0;
      let x0 = graph.yaxis;
      let y0 = graph.xaxis;
      let c;
      context.strokeStyle = s;
      context.fillStyle = s;
      context.lineWidth = w;
      context.setLineDash(ld);
      SkewGraph();
      context.beginPath();
      if(graph.type === "explicit"){
        //  グラフ  折れ線描画法
        d = 0;
        for(let i=(-x0-Math.max(sx*(-y0),sx*(740-y0)))/(1-sx*sy); i<=(920-x0-Math.min(sx*(-y0),sx*(740-y0)))/(1-sx*sy); i+=2){
          x = i/graph.scale;
          if(Number.isNaN(f(x))){
            if(d){
              //  何かしらの描画があるとき
              SkewGraph(1);
              context.stroke();
              SkewGraph();
              context.beginPath();
              d = 0;
            }
          }else{
            c = Math.abs(f(x))===Infinity ? {bool:true,x:x,d:2/graph.scale} : isContinuous(f,x,2/graph.scale);
            if(c.bool){
              y = f(x);
              y = -y*graph.scale;
              y = Math.min(Math.max(y,-(y0-Math.min(sy*(-x0),sy*(920-x0)))/(1-sx*sy)-10),-(y0-740-Math.max(sy*(-x0),sy*(920-x0)))/(1-sx*sy)+10);
              context.lineTo(i,y);
              d = 1;
            }
            else{
              //  不連続かつ大きいとき!!!
              y = f(c.x);
              y = -y*graph.scale;
              y = Math.min(Math.max(y,-(y0-Math.min(sy*(-x0),sy*(920-x0)))/(1-sx*sy)-10),-(y0-740-Math.max(sy*(-x0),sy*(920-x0)))/(1-sx*sy)+10);
              context.lineTo(i,y);
              SkewGraph(1);
              context.stroke();
              SkewGraph();
              y = f(c.x+c.d);
              y = -y*graph.scale;
              y = Math.min(Math.max(y,-(y0-Math.min(sy*(-x0),sy*(920-x0)))/(1-sx*sy)-10),-(y0-740-Math.max(sy*(-x0),sy*(920-x0)))/(1-sx*sy)+10);
              context.beginPath();
              context.moveTo(i,y);
              d = 1;
            }
          }
        }
      }
      else if(graph.type === "polar"){
        d = 0;
        for(let i=r[0]; i<r[1]; i+=.01){
          if(Number.isNaN(f(i))){
            if(d){
              SkewGraph(1);
              context.stroke();
              SkewGraph();
              context.beginPath();
              d = 0;
            }
          }else{
            c = Math.abs(f(i))===Infinity ? {bool:true,x:i,d:.01} : isContinuous(f,i,.01);
            if(c.bool){
              y = f(i)*graph.scale;
              context.lineTo(y*Math.cos(i),-y*Math.sin(i));
              d = 1;
            }
            else{
              y = f(c.x)*graph.scale;
              context.lineTo(y*Math.cos(i),-y*Math.sin(i));
              SkewGraph(1);
              context.stroke();
              SkewGraph();
              y = f(c.x+c.d)*graph.scale;
              context.beginPath();
              context.moveTo(y*Math.cos(i),-y*Math.sin(i));
              d = 1;
            }
          }
        }
      }
      else if(graph.type === "parameter"){
        d = 0;
        for(let i=r[0]; i<r[1]+Math.min(.1,(r[1]-r[0])/1000); i+=Math.min(.1,(r[1]-r[0])/1000)){
          if(r[1]<=i)i = r[1];//  最後の点
          if(Number.isNaN(f(i))){
            if(d){
              SkewGraph(1);
              context.stroke();
              SkewGraph();
              context.beginPath();
              d = 0;
            }
          }else{
            c = [
              Math.abs(f(i)[0])===Infinity ? {bool:true,x:i,d:Math.min(.1,(r[1]-r[0])/1000)} : isContinuous((t)=>f(t)[0],i,Math.min(.1,(r[1]-r[0])/1000)),
              Math.abs(f(i)[1])===Infinity ? {bool:true,x:i,d:Math.min(.1,(r[1]-r[0])/1000)} : isContinuous((t)=>f(t)[1],i,Math.min(.1,(r[1]-r[0])/1000))
            ];
            if(c[0].bool&&c[1].bool){
              y = f(i);
              context.lineTo(y[0]*graph.scale,-y[1]*graph.scale);
              d = 1;
            }
            else{
              y = c[0].bool ? f(c[1].x) : f(c[0].x);
              context.lineTo(y[0]*graph.scale,-y[1]*graph.scale);
              SkewGraph(1);
              context.stroke();
              SkewGraph();
              y = c[0].bool ? f(c[1].x+c[1].d) : f(c[0].x+c[0].d);
              context.beginPath();
              context.moveTo(y[0]*graph.scale,-y[1]*graph.scale);
              d = 1;
            }
          }
        }
      }
      else if(graph.type === "implicit"){
        SkewGraph(1);
        let v = [];
        let d = ld.length ? 6 : 4;
        for(let j=0; j<=740/d; j++){
          v.push([]);
          y = (y0-j*d)/graph.scale;
          for(let i=0; i<=920/d; i++){
            x = (i*d-x0)/graph.scale;
            v[j].push(Math.sign(f(x,y)));
          }
        }
        for(let j=0; j<=740/d-1; j++){
          for(let i=0; i<=920/d-1; i++){
            if(v[j][i]*v[j][i+1]<=0){
              context.moveTo(i*d+d/2,j*d);
              context.arc(i*d+d/2,j*d,w/2,0,Math.PI*2);
            }
            if(v[j][i]*v[j+1][i]<=0){
              context.moveTo(i*d,j*d+d/2);
              context.arc(i*d,j*d+d/2,w/2,0,Math.PI*2);
            }
          }
        }
        context.fill();
        context.beginPath();
        SkewGraph();
      }
      SkewGraph(1);
      context.stroke();
    }

    function DrawControls(b){
      let gra0 = ctx.createLinearGradient(0,-50,0,50);
      gra0.addColorStop(0,"#afa");
      gra0.addColorStop(1,"#5d5");
      let gra1 = ctx.createLinearGradient(0,-50,0,50);
      gra1.addColorStop(0,"#aaa");
      gra1.addColorStop(1,"#777");
      //  スライダー
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      for(let i=0; i<4; i++){
        if(b){
          btx.save();
          btx.translate(500,950+130*i);
          //  上限と下限のディスプレイ
          btx.fillStyle = "#000";
          btx.strokeStyle = "#333";
          btx.lineWidth = 5;
          SetRRPath(btx,-460,-40,100,80,15);
          btx.fill();
          btx.stroke();
          SetRRPath(btx,+360,-40,100,80,15);
          btx.fill();
          btx.stroke();
          //  スライダーの背景
          btx.beginPath();
          btx.arc(-300,0,5,Math.PI,-Math.PI);
          btx.arc(+300,0,5,0,Math.PI*2);
          btx.lineWidth = 10;
          btx.strokeStyle = "#888";
          btx.shadowBlur = 5;
          btx.shadowColor = "#eee";
          btx.shadowOffsetX = 5;
          btx.shadowOffsetY = 5;
          btx.stroke();
          btx.shadowColor = "#555";
          btx.shadowOffsetX = -5;
          btx.shadowOffsetY = -5;
          btx.stroke();
          btx.restore();
        }
        ctx.save();
        ctx.translate(500,950+130*i);
        //  上限と下限
        ctx.fillStyle = "#f00";
        ctx.font = "50px 'Roboto Mono'";
        ctx.fillText(vars[i].available ? vars[i].min : "",-410,0,80);
        ctx.fillText(vars[i].available ? vars[i].max : "",+410,0,80);
        //  可動部
        ctx.lineWidth = 5;
        ctx.fillStyle = vars[i].available ? gra0 : gra1;
        ctx.strokeStyle = "#333";
        ctx.shadowColor = "#444";
        ctx.shadowBlur = 15;
        ctx.shadowOffsetX = 10;
        ctx.shadowOffsetY = 10;
        ctx.translate(vars[i].proportion*600-300,0);
        SetRRPath(ctx,-25,-50,50,100,10);
        ctx.fill();
        ctx.shadowColor = "#00000000";
        ctx.stroke();
        ctx.fillStyle = "#333";
        ctx.font = "50px 'Roboto Mono'";
        ctx.fillText("abcd"[i],0,0);
        ctx.restore();
      }



      //  ボタン
      ctx.lineWidth = 5;
      ctx.strokeStyle = "#333";
      ctx.font = "70px 'Roboto Mono'";
      for(let i=0; i<3; i++){
        ctx.save();
        ctx.translate(180+320*i,1560);
        ctx.fillStyle = buttons[["prev","reset","next"][i]].available ? gra0 : gra1;
        SetRRPath(ctx,-140,-50,280,100,20);
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = "#333";
        ctx.fillText(["PREV","RESET","NEXT"][i],0,0);
        ctx.restore();
      }
    }

    function isContinuous(f,x,d,c=0){
      //  正確かつ迅速な不連続判定を実装する!!!
      //if(Math.min(f(x),f(x+d))<f(x+d/2)&&f(x+d/2)<Math.max(f(x),f(x+d))){
      if(Math.abs(Math.atan2(f(x+d/2)-f(x),d/2)-Math.atan2(f(x+d)-f(x+d/2),d/2))<.01){
        //  連続とみなす
        return {bool:true};
      }
      else{
        if(8<=c)return {bool:false,x:x,d:d};
        //  不連続かもしれない
        let c0 = isContinuous(f,x,d/2,c+1);
        let c1 = isContinuous(f,x+d/2,d/2,c+1);
        if(c0.bool&&c1.bool){
          return {bool:true};
        }else{
          let c = c0.bool ? c1 : c0;
          return {bool:false,x:c.x,d:c.d};
        }
      }
    }

    //  (x,y)が矩形内にあるかどうか
    function IsIn(x,y,x0,y0,w,h){
      let bool = 1;
      bool = bool && x0 < x;
      bool = bool && x < x0+w;
      bool = bool && y0 < y;
      bool = bool && y < y0+h;
      return bool;
    }

    //  角丸矩形の描画
    function SetRRPath(context,x,y,w,h,r){
      context.beginPath();
      context.moveTo(x,y + r);
      context.arc(x+r,y+h-r,r,Math.PI,Math.PI*0.5,true);
      context.arc(x+w-r,y+h-r,r,Math.PI*0.5,0,1);
      context.arc(x+w-r,y+r,r,0,Math.PI*1.5,1);
      context.arc(x+r,y+r,r,Math.PI*1.5,Math.PI,1);
      context.closePath();
    }

    //  滑らかに変化する値を返す
    //  t=0 => a
    //  t=1 => b
    //  t=2 => c
    function Smooth(t,a,b,c){
      if(t<0 || 2<t){
        console.error("Unexpected value");
      }else if(t<1){
        return a+(b-a)/2*(1-Math.cos(Math.PI*t));
      }else{
        return b+(c-b)/2*(1+Math.cos(Math.PI*t));
      }
    }











  </script>
</html>
