<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
    <title>Graph Me</title>
    <link rel="icon" href="data:,">
    <link rel="stylesheet" href="../Style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inconsolata&display=swap" rel="stylesheet">
    <style>
      *{
        font-size: 0;
        overflow: hidden;
        display: inline-block;
        text-align: center;
      }

      @font-face
      {
        font-family: 'Inconsolata';
        font-style: normal;
        font-weight: 100;
        src: url('mplus1p-thin.eot');  /* IE9+ */
        src: url('mplus1p-thin.eot?#iefix') format('embedded-opentype'),  /* IE8- */
             url('mplus1p-thin.woff') format('woff'),     /* その他のブラウザ */
             url('mplus1p-thin.ttf') format('truetype');  /* 古いiOS */
      }
    </style>
  </head>
  <body>
    <div id="wrapper">
      <canvas id="main_canvas" width="1000" height="1650"></canvas>
    </div>
  </body>
  <script type="text/javascript" src="scripts/Graph Me.js"></script>
  <script type="text/javascript" src="scripts/webfont.js"></script>
  <script type="text/javascript">
    //


    /*
    参考資料等

    使用フォント:Inconsolata(Google fonts)
    https://fonts.google.com/specimen/Inconsolata?query=inconsola#standard-styles

    フォントのロードの検知:Web Font Loader
    参考:http://ithat.me/2016/12/10/js-web-font-load-start-complete-detection-web-font-loader

    音源
    ・フリー効果音素材 くらげ工匠 : http://www.kurage-kosho.info/
      =>ボタン押下 - button68.mp3
      =>スライダー移動 - button45.mp3
    ・効果音ラボ : https://soundeffect-lab.info/
      =>クリア - データ解析.mp3
    */


    alert("script loaded");
    let Sleep = ms => new Promise(r=>setTimeout(r,ms));
    Math.mod = (x,m)=>(x%m+m)%m;//  勝手にmod関数を定義
    let cvs,ctx,touches,buttons,vars,graph,ctrl,level,clear,colors,cdata,cdata0,audio,interacted;
    interacted = 0;





    //  マウス対応!!!
    //  フォントの読み込み後に開始
    WebFont.load({
      //custom : {
      custom : {
        families : ["Inconsolata"]
      },
      active : () => {
        alert("font loaded");
        return 0;
        Init();
        ctx.fillStyle = "#00000080";
        ctx.fillRect(0,0,1000,1650);
        ctx.font = "160px Inconsolata";
        ctx.fillStyle = "#ffffffc0";
        ctx.fillText("TAP TO START",1000/2,1650/2);

        //  リサイズ時, canvasを画面の大きさに合わせる
        window.onresize = () => {Resize();}
        //  操作
        if(window.ontouchstart === null){
          //  タッチ操作
          cvs.ontouchstart = (e) => {
            if(!interacted)return false;
            if(!ctrl)return 0;
            e.preventDefault();
            let x = e.touches[0].clientX-cvs.getBoundingClientRect().left;//  canvas左上からのpx値
            let y = e.touches[0].clientY-cvs.getBoundingClientRect().top;
            let wp = cvs.width;
            let wr = cvs.getBoundingClientRect().width;
            let hp = cvs.height;
            let hr = cvs.getBoundingClientRect().height;
            let r = window.innerWidth/20;

            //  スライダーの判定
            for(let i=0; i<4; i++){
              ctx.fillStyle = "#ff00ff20";
              ctx.fillRect(vars[i].proportion*600+200-50,950+i*130-50,100,100);
              if(IsIn(x,y,(vars[i].proportion*600+200)/wp*wr-r,(950+i*130)/wp*wr-r,r*2,r*2)){//  canvas内の点の座標を戻す
                buttons.slider = i;
                break;
              }
            }

            //  ボタンの判定
            if(IsIn(x,y,40/wp*wr,1510/wp*wr,280/wp*wr,100/wp*wr)&&buttons.prev.available){
              Prev(1);
              audio.button.PLAY();
            };
            if(IsIn(x,y,360/wp*wr,1510/wp*wr,280/wp*wr,100/wp*wr)&&buttons.reset.available){
              Reset(1);
              audio.button.PLAY();
            };
            if(IsIn(x,y,680/wp*wr,1510/wp*wr,280/wp*wr,100/wp*wr)&&buttons.next.available){
              Next(1);
              audio.button.PLAY();
            };

            //  タッチ操作は一つのみ有効
            ctrl = 0;
            DrawAll();
          }
          cvs.ontouchmove = (e) => {
            if(!interacted)return false;
            e.preventDefault();
            let x = e.touches[0].clientX-cvs.getBoundingClientRect().left;
            x *= cvs.width;
            x /= cvs.getBoundingClientRect().width;
            let v;

            //  スライダー操作
            if(0<=buttons.slider){
              v = vars[buttons.slider];
              let d = Math.round(v.proportion*10)/10;
              v.value = (v.max-v.min)*Math.min(Math.max((x-200)/600,0),1)+v.min;
              v.adapt();
              d = Math.round(v.proportion*10)/10-d;
              if(.04<Math.abs(d)){
                audio.slider.PLAY();
              }
              SetButtons();
            }
            DrawAll();

            if(graph.type === "title"){
              Check();
            }
            else if(graph.type === "settings"){
              AdaptSettings();
            }
          }
          cvs.ontouchend = () => {
            if(!interacted){
              interacted = 1;
              Reset();
              return false;
            }
            buttons.slider = -1;
            Check();
            ctrl = 1;
          }
        }else{
          //  マウス操作
        }
      },
      inactive : () => {
        alert("フォント読み込み失敗");
      }
    });



    function LoadCookie(){
      cdata0 = {
        maxlevel : 1,
        analog : 0,
        color : 0,
        weight : 10,
        sound : .2
      };
      if(!document.cookie.length){
        //  初訪問
        cdata = {};
        for(let k in cdata0){
          cdata[k] = cdata0[k];
        }
      }
      else{
        let cookies = document.cookie.split(";");
        if(cookies.length < Object.keys(cdata0).reduce((a,b)=>Math.max(+a,+b))){
          ClearCookie();
          LoadCookie();
          return 0;
        }
        cdata = {};
        for(let i=0; i<cookies.length; i++){
          cdata[cookies[i].split("=")[0].replace(/\s/g,"")] = +decodeURIComponent(cookies[i].split("=")[1]);
        }
      }
      colors = {
        get main(){return ["#ffff00","#00ff00","#c000ff"][cdata.color];},
        get main_(){return ["#ffff0040","#00ff0040","#c000ff40"][cdata.color];},
        get hint(){return ["#00ffff","#ff00c0","#ffc000"][cdata.color];},
        get disabled(){return ["#888888"][0];},
        get disabled_(){return ["#88888840"][0];},
        get message(){return ["#ffffff"][0];},
        get message_(){return ["#ffffff40"][0];}
      }
      audio.slider.volume = cdata.sound;
      audio.button.volume = cdata.sound;
      audio.clear.volume = Math.min(cdata.sound*1.6,1);
    }

    function SaveCookie(){
      for(let k in cdata){
        document.cookie =  `${k}=${encodeURIComponent(String(cdata[k]))};max_age=315360000;`;//  10年
      }
    }

    function ClearCookie(){
      alert(`clear cookie : ${document.cookie}`);
      let cookies = document.cookie.split(";");
      for(let i=0; i<cookies.length; i++){
        document.cookie = `${cookies[i]};max-age=0;`;
      }
    }

    /*

    function Resize(){
      let len = Math.min(window.innerWidth/20,window.innerHeight/33)*.95;
      cvs.style.width = `${len*20}px`;
    }

    function Init(){
      cvs = document.querySelector("#main_canvas");
      ctx = cvs.getContext("2d");
      ctx.lineJoin = "round";
      ctx.lineCap = "round";
      ctx.shadowColor = "#c0ffc0";
      touches = {};
      buttons = {
        prev : {
          //down : 0,  ボタン押下時の見た目はそのままでよいのか!!!???
          available : 0
        },
        reset : {
          //down : 0,
          available : 1
        },
        next : {
          //down : 0,
          available : 0
        },
        slider : -1
      };
      graph = {
        colors : {
          get main(){return cdata.analog ? "#d0ffd0" : colors.main;},
          get main_(){return cdata.analog ? "#d0ffd040" : colors.main_;},
          get hint(){return cdata.analog ? "#d0ffd0" : colors.hint;},
          get disabled(){return cdata.analog ? "#80a080" : colors.disabled;},
          get disabled_(){return cdata.analog ? "#80a08040" : colors.disabled_;},
          get message(){return cdata.analog ? "#d0ffd0" : colors.message;},
          get message_(){return cdata.analog ? "#d0ffd040" : colors.message_;}
        }
      };
      vars = [];
      for(let i=0; i<4; i++){
        vars.push({});
        Object.defineProperty(vars[i],"proportion",{
          get : () => {
            let v = vars[i];
            return (v.value-v.min)/(v.max-v.min);
          }
        });
        Object.defineProperty(vars[i],"adapt",{
          value : () => {
            let v = vars[i];
            if(v.scale){
              v.value = v.scale*Math.round((v.value-v.min)/v.scale)+v.min;
            }
          }
        });
      }
      ctrl = 1;//  使用した記憶なし．要確認!!!
      level = 0;//  0はタイトル画面
      clear = 0;//  レベルごとに使用. 0:未, 1:済
      audio = {
        slider : new Audio("sounds/button45.mp3"),
        button : new Audio("sounds/button68.mp3"),
        clear : new Audio("sounds/データ解析.mp3")
      };
      for(let a in audio){
        audio[a].PLAY = ()=>{
          audio[a].currentTime = 0;
          audio[a].play();
        };
      }

      //  クッキーがあれば，そのデータを代入する
      LoadCookie();
      //  Resetによる初期化
      Resize();
      Reset();
    }

    //  ボタン設定
    function SetButtons(){
      if(graph.type==="title"){
        buttons.prev.available = 1;
        buttons.reset.available = 1;
      }
      else if(graph.type === "stages"){
        buttons.prev.available = 1;
        if(vars[0].value-1+(vars[1].value-1)*4<=Math.ceil(cdata.maxlevel/12)-1){
          //  nextボタン
          buttons.next.available = 1;
        }else{
          buttons.next.available = 0;
        }
        buttons.reset.available = 1;
      }
      else if(graph.type === "settings"){
        buttons.prev.available = 1;
        buttons.next.available = 0;
        buttons.reset.available = 1;
      }
      else if(graph.type === "levels"){
        if(vars[0].value+(vars[1].value-1)*4<=cdata.maxlevel){
          //  nextボタン
          buttons.next.available = 1;
        }else{
          buttons.next.available = 0;
        }
        buttons.reset.available = 1;
      }
      else{
        buttons.prev.available = 1;
        buttons.reset.available = 1;
        buttons.next.available = +(level<cdata.maxlevel);
      }
    }

    //  設定の適用
    function AdaptSettings(){
      cdata.analog = vars[0].value;
      cdata.color = vars[1].value;
      SaveCookie();
    }

    //  クリア判定等
    function Check(){
      if(graph.type === "title"){
        //  タイトル画面スライド後の処理
        if(Math.min(Math.abs(vars[2].value-0),Math.abs(vars[2].value-1),Math.abs(vars[2].value-2))<=2/30){
          buttons.next.available = 1;
        }else{
          buttons.next.available = 0;
        }
        DrawAll();
        return 0;
      }
      if(graph.type === "stages")return 0;
      if(graph.type === "levels")return 0;
      let bool = 1;
      for(let i=0; i<4; i++){
        if(!vars[i].available)continue;
        if(Math.abs(vars[i].value-problems[level].answer[i])>(vars[i].max-vars[i].min)/30){
          bool = 0;
        }
      }
      if(bool)Clear();
    }

    //  クリア後の処理
    async function Clear(){
      for(let i=0; i<4; i++){
        if(vars[i].available)
          vars[i].value = problems[level].answer[i];
      }
      if(clear)return 0;
      SaveCookie();
      audio.clear.PLAY();
      await Sleep(50);
      Unlock(level+1);
      SetButtons();
      clear = 1;
      DrawAll();
    }

    */

    //  レベルnの開放
    function Unlock(n){
      cdata.maxlevel = Math.max(cdata.maxlevel,Math.min(n,Object.keys(problems).reduce((a,b)=>Math.max(+a,+b))));
      SetButtons();
      clear = 0;
      DrawAll();
    }

    //  ステージ・レベル選択画面の描画
    function DrawSelect(b){
      graph.scale = 55;
      vars[0].available = 1;
      vars[0].min = 1;
      vars[0].max = 4;
      vars[0].value = b ? ((level-1)%12)%4+1 : 1;
      vars[0].scale = 1;
      vars[1].available = 1;
      vars[1].min = 1;
      vars[1].max = 3;
      vars[1].value = b ? Math.floor(((level-1)%12)/4)+1 : 1;
      vars[1].scale = 1;
      vars[2].available = 0;
      vars[3].available = 0;
      SetButtons();
      DrawAll();
    }

    //  設定画面の描画
    function DrawSettings(){
      graph.scale = 148/2;
      vars[0].available = 1;
      vars[0].min = 0;
      vars[0].max = 1;
      vars[0].scale = 1;
      vars[0].value = cdata.analog;
      vars[1].available = 1;
      vars[1].min = 0;
      vars[1].max = 3;
      vars[1].scale = 1;
      vars[1].value = cdata.color;
      vars[2].available = 1;
      vars[2].min = 0;
      vars[2].max = 20;
      vars[2].scale = 0;
      vars[2].value = cdata.weight;
      vars[3].available = 1;
      vars[3].min = 0;
      vars[3].max = 1;
      vars[3].scale = 0;
      vars[3].value = cdata.sound;
      SetButtons();
      DrawAll();
    }

    //  prevボタン押下時の処理
    function Prev(){
      if(graph.type === "title"){
        //  ホームページへ
        location.href = "https://tomoq1024.github.io/WebApps/";
      }
      else if(graph.type === "settings"){
        Reset();
      }
      else if(graph.type === "stages"){
        level = 0;
        Reset();
      }
      else if(graph.type === "levels"){
        graph.type = "stages";
        SetButtons();
        DrawAll();
      }
      else{
        //  任意のレベル
        graph.type = "levels";
        clear = 0;
        SetButtons();
        DrawSelect(1);
      }
    }

    //  resetボタン押下時の処理
    //  問題画面の初期化. 最初の表示にも用いる
    //  設定の初期化!!!
    function Reset(b){
      if(b){
        //  手動押下時
        if(graph.type === "title"){
          location.reload();
          return 0;
        }
        else if(graph.type === "settings"){
          DrawSettings();
          return 0;
        }
        else if(graph.type === "stages"){
          DrawSelect();
          return 0;
        }
        else if(graph.type === "levels"){
          DrawSelect();
          return 0;
        }
        else if(graph.type === "settings"){
          DrawSettings();
          return 0;
        }
      }
      //  自動押下時
      //  グラフの設定
      let p = problems[level];
      graph.type = p.type;
      graph.xaxis = p.xaxis;
      graph.yaxis = p.yaxis;
      graph.scale = p.gscale;
      graph.func = p.func;
      for(let i=0; i<4; i++){
        vars[i].available = p.vars[i];
        vars[i].min = p.min[i];
        vars[i].value = p.value[i];
        vars[i].max = p.max[i];
        vars[i].scale = p.vscale[i];
      }
      clear = 0;

      //  ボタンの設定
      SetButtons();

      DrawAll();
    }

    //  nextボタン押下時の処理
    function Next(){
      if(graph.type === "title"){
        if(Math.abs(vars[2].value-0)<=2/30){
          //  ステージ選択へ
          graph.type = "stages";
          SetButtons();
          DrawSelect();
        }
        else if(Math.abs(vars[2].value-1)<=2/30){
          //  設定画面へ
          graph.type = "settings";
          SetButtons();
          DrawSettings();
        }
        else if(Math.abs(vars[2].value-2)<=2/30){
          //  砂場にする!!!
        }
      }
      else if(graph.type === "stages"){
        graph.type = "levels";
        level = (vars[0].value-1+(vars[1].value-1)*4)*12+1;
        DrawSelect();
      }
      else if(graph.type === "levels"){
        level = Math.floor((level-1)/12)*12 + vars[0].value-1+(vars[1].value-1)*4 + 1;
        Reset();
      }
      else{
        level += 1;
        Reset();
      }
    }

    function DrawAll(){
      DrawBackground();
      DrawScreen();
      DrawControls();
    }

    function DrawBackground(){
      ctx.fillStyle = "#ccc";
      ctx.fillRect(0,0,cvs.width,cvs.height);
    }

    function DrawScreen(){
      ctx.save();

      //  描画範囲の指定
      ctx.beginPath();
      ctx.moveTo(40,40);
      ctx.lineTo(40,780);
      ctx.lineTo(960,780);
      ctx.lineTo(960,40);
      ctx.closePath();
      ctx.clip();

      //  スクリーン左上を原点とする
      ctx.translate(40,40);

      //  背景
      if(cdata.analog){
        let gra = ctx.createRadialGradient(460,370,0,460,370,1000);
        gra.addColorStop(0.0,"#246347");
        gra.addColorStop(0.7,"#133828");
        gra.addColorStop(1.0,"#091c14");
        ctx.fillStyle = gra;
        ctx.fillRect(-10,-10,940,760);
      }
      else{
        ctx.fillStyle = "#000";
        ctx.fillRect(-10,-10,940,760);
      }

      //  グリッド
      //  レベル選択に戻ったとき，グリッドの設定を戻す!!!
      ctx.strokeStyle = cdata.analog ? "#333" : "#444";
      for(let i=Math.ceil(-graph.yaxis/graph.scale); i<=(920-graph.yaxis)/graph.scale; i++){
        ctx.lineWidth = i%5 ? 4 : 6;
        ctx.beginPath();
        ctx.moveTo(graph.yaxis+i*graph.scale,0);
        ctx.lineTo(graph.yaxis+i*graph.scale,740);
        ctx.stroke();
      }
      for(let i=Math.ceil(-graph.xaxis/graph.scale); i<=(740-graph.xaxis)/graph.scale; i++){
        ctx.lineWidth = i%5 ? 4 : 6;
        ctx.beginPath();
        ctx.moveTo(0,graph.xaxis+i*graph.scale);
        ctx.lineTo(920,graph.xaxis+i*graph.scale);
        ctx.stroke();
      }
      //  軸
      ctx.lineWidth = 8;
      ctx.strokeStyle = cdata.analog ? "#333" : "#777";
      ctx.beginPath();
      ctx.moveTo(graph.yaxis,0);
      ctx.lineTo(graph.yaxis,740);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0,graph.xaxis);
      ctx.lineTo(920,graph.xaxis);
      ctx.stroke();

      //  レベルの表示
      if(graph.type==="explicit"){
        ctx.fillStyle = cdata.analog ? "#222" : "#888";
        ctx.textAlign = "left";
        ctx.textBaseline = "bottom";
        ctx.font = "70px Inconsolata";
        ctx.fillText(
          `${(Math.floor((level-1)/12)+1).toString(16).toUpperCase()}-${((level-1)%12+1).toString(16).toUpperCase()}`,
          10,740-10
        );
      }

      //  グラフ
      if(graph.type == "title"){
        //  タイトル画面
        //  quitはprevボタンで代用できるため，sandbox等に置き換えるべき!!!
        ctx.strokeStyle = graph.colors.main;
        ctx.lineWidth = 10;
        if(cdata.analog)ctx.shadowBlur = 10;

        //  タイトル画面(改)
        let t = vars[2].value;
        for(let i=0; i<8; i++){
          for(let j=0; j<2; j++){
            ctx.save();
            ctx.translate(35+110*i,120+340*j);
            ctx.scale(80/2,160/2);
            switch(`${j}${i}`){
              case "00":
                //  G
                ctx.beginPath();
                ctx.moveTo(2,0);
                ctx.lineTo(0,0);
                ctx.lineTo(0,2);
                ctx.lineTo(2,2);
                ctx.lineTo(2,1);
                ctx.lineTo(1,1);
                break;
              case "01":
                //  R
                ctx.beginPath();
                ctx.moveTo(0,2);
                ctx.lineTo(0,0);
                ctx.lineTo(2,0);
                ctx.lineTo(2,1);
                ctx.lineTo(0,1);
                ctx.moveTo(1,1);
                ctx.lineTo(2,2);
                break;
              case "02":
                //  A
                ctx.beginPath();
                ctx.moveTo(0,2);
                ctx.lineTo(0,0);
                ctx.lineTo(2,0);
                ctx.lineTo(2,2);
                ctx.moveTo(0,1);
                ctx.lineTo(2,1);
                break;
              case "03":
                //  P
                ctx.beginPath();
                ctx.moveTo(0,2);
                ctx.lineTo(0,0);
                ctx.lineTo(2,0);
                ctx.lineTo(2,1);
                ctx.lineTo(0,1);
                break;
              case "04":
                //  H
                ctx.beginPath();
                ctx.moveTo(0,2);
                ctx.lineTo(0,0);
                ctx.moveTo(2,0);
                ctx.lineTo(2,2);
                ctx.moveTo(0,1);
                ctx.lineTo(2,1);
                break;
              case "05":
                //  _
                ctx.moveTo(0,2);
                ctx.lineTo(2,2);
                break;
              case "06":
                //  M
                ctx.beginPath();
                ctx.moveTo(0,2);
                ctx.lineTo(0,0);
                ctx.lineTo(2,0);
                ctx.lineTo(2,2);
                ctx.moveTo(1,0);
                ctx.lineTo(1,2);
                break;
              case "07":
                //  E
                ctx.beginPath();
                ctx.moveTo(2,0);
                ctx.lineTo(0,0);
                ctx.lineTo(0,2);
                ctx.lineTo(2,2);
                ctx.moveTo(0,1);
                ctx.lineTo(2,1);
                break;

              case "10":
                //  _S_
                ctx.beginPath();
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,2,0,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,0,2));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,2,1,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,1,2));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,2,2,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,2,2));
                ctx.moveTo(Smooth(t,2,0,2),Smooth(t,2,0,2));
                ctx.lineTo(Smooth(t,2,0,2),Smooth(t,2,1,2));
                ctx.moveTo(Smooth(t,0,2,0),Smooth(t,2,1,2));
                ctx.lineTo(Smooth(t,0,2,0),Smooth(t,2,2,2));
                break;
              case "11":
                //  _E_
                ctx.beginPath();
                ctx.moveTo(Smooth(t,2,2,2),Smooth(t,2,0,2));
                ctx.lineTo(Smooth(t,0,0,0),Smooth(t,2,0,2));
                ctx.lineTo(Smooth(t,2,0,2),Smooth(t,2,1,2));
                ctx.lineTo(Smooth(t,0,0,0),Smooth(t,2,2,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,2,2));
                ctx.moveTo(Smooth(t,2,0,2),Smooth(t,2,1,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,1,2));
                break;
              case "12":
                //  PTQ
                ctx.beginPath();
                ctx.moveTo(Smooth(t,0,1,0),Smooth(t,0,0,0));
                ctx.lineTo(Smooth(t,0,1,0),Smooth(t,2,2,2));
                ctx.moveTo(Smooth(t,2,1,2),Smooth(t,0,0,0));
                ctx.lineTo(Smooth(t,2,1,2),Smooth(t,1,2,2));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,0,0,0));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,0,0,0));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,1,0,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,1,0,2));
                ctx.moveTo(Smooth(t,0,1,1),Smooth(t,1,0,1));
                ctx.lineTo(Smooth(t,0,1,2),Smooth(t,2,2,2));
                break;
              case "13":
                //  LTU
                ctx.beginPath();
                ctx.moveTo(Smooth(t,0,1,0),Smooth(t,0,0,0));
                ctx.lineTo(Smooth(t,0,1,0),Smooth(t,2,2,2));
                ctx.moveTo(Smooth(t,0,1,2),Smooth(t,0,0,0));
                ctx.lineTo(Smooth(t,0,1,2),Smooth(t,2,2,2));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,2,0,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,0,2));
                break;
              case "14":
                //  AII
                ctx.beginPath();
                ctx.moveTo(Smooth(t,0,1,1),Smooth(t,0,0,0));
                ctx.lineTo(Smooth(t,0,1,1),Smooth(t,2,2,2));
                ctx.moveTo(Smooth(t,2,1,1),Smooth(t,0,0,0));
                ctx.lineTo(Smooth(t,2,1,1),Smooth(t,2,2,2));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,0,0,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,0,0,2));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,1,2,0));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,1,2,0));
                break;
              case "15":
                //  YNT
                ctx.beginPath();
                ctx.moveTo(Smooth(t,0,0,1),Smooth(t,0,0,0));
                ctx.lineTo(Smooth(t,0,0,1),Smooth(t,1,2,2));
                ctx.moveTo(Smooth(t,2,2,1),Smooth(t,0,0,0));
                ctx.lineTo(Smooth(t,2,2,1),Smooth(t,1,2,2));
                ctx.moveTo(Smooth(t,1,1,1),Smooth(t,1,0,0));
                ctx.lineTo(Smooth(t,1,1,1),Smooth(t,2,2,2));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,1,0,0));
                ctx.lineTo(Smooth(t,1,1,1),Smooth(t,1,0,0));
                ctx.moveTo(Smooth(t,1,1,1),Smooth(t,1,2,0));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,1,2,0));
                break;
              case "16":
                //  _G_
                ctx.beginPath();
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,2,0,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,0,2));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,2,2,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,2,2));
                ctx.moveTo(Smooth(t,1,1,1),Smooth(t,2,1,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,1,2));
                ctx.moveTo(Smooth(t,2,0,2),Smooth(t,2,0,2));
                ctx.lineTo(Smooth(t,2,0,2),Smooth(t,2,2,2));
                ctx.moveTo(Smooth(t,1,2,0),Smooth(t,2,1,2));
                ctx.lineTo(Smooth(t,1,2,0),Smooth(t,2,2,2));
                break;
              case "17":
                //  _S_
                ctx.beginPath();
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,2,0,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,0,2));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,2,1,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,1,2));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,2,2,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,2,2));
                ctx.moveTo(Smooth(t,0,0,0),Smooth(t,2,0,2));
                ctx.lineTo(Smooth(t,2,0,2),Smooth(t,2,1,2));
                ctx.moveTo(Smooth(t,0,2,0),Smooth(t,2,1,2));
                ctx.lineTo(Smooth(t,2,2,2),Smooth(t,2,2,2));
                break;
            }
            ctx.restore();
            ctx.stroke();
          }
        }

        ctx.shadowBlur = 0;
      }
      else if(graph.type == "settings"){
        //  設定画面
        ctx.strokeStyle = graph.colors.main;
        ctx.fillStyle = graph.colors.main;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = "100px,Inconsolata";
        ctx.fillText(`DISPLAY - ${cdata.analog?"ANALOG ":"DIGITAL"}`,920/2,148*1);
        ctx.fillText(`COLOR   -        `,920/2,148*2);
        ctx.fillText(`WEIGHT  -        `,920/2,148*3);
        ctx.fillText(`SOUND   -        `,920/2,148*4);

        ctx.beginPath();
        ctx.moveTo(920/2,148*2);
      }
      else if(graph.type == "stages"){
        //  ステージ選択
        //  ボタンの枠
        //  クリアしたら緑にする???
        ctx.lineWidth = 15;
        for(let y=0; y<3; y++){
          for(let x=0; x<4; x++){
            ctx.strokeStyle = x+y*4<=Math.ceil(cdata.maxlevel/12)-1 ? graph.colors.main : graph.colors.disabled;
            ctx.fillStyle = x+y*4<=Math.ceil(cdata.maxlevel/12)-1 ? graph.colors.main_ : graph.colors.disabled_;
            ctx.fillRect(50+220*x,70+220*y,160,160);
            if(cdata.analog)ctx.shadowBlur = 10;
            ctx.strokeRect(50+220*x,70+220*y,160,160);
            ctx.shadowBlur = 0;
            if(x+y*4 === vars[0].value-1+(vars[1].value-1)*4){
              ctx.fillRect(50+220*x,70+220*y,160,160);
              ctx.fillRect(50+220*x,70+220*y,160,160);
              if(cdata.analog)ctx.shadowBlur = 10;
              ctx.strokeRect(50+220*x-10,70+220*y-10,160+20,160+20);
              ctx.shadowBlur = 0;
            }
          }
        }
        //  ボタンのデザイン
        ctx.strokeStyle = graph.colors.main;
        ctx.strokeStyle = 0<=Math.ceil(cdata.maxlevel/12)-1 ? graph.colors.main : graph.colors.disabled;
        ctx.beginPath();
        ctx.moveTo(130+220*0-40,150+220*0-40);//  1:礎
        ctx.lineTo(130+220*0+0,150+220*0+40);
        ctx.lineTo(130+220*0+40,150+220*0-40);
        ctx.stroke();
        ctx.strokeStyle = 1<=Math.ceil(cdata.maxlevel/12)-1 ? graph.colors.main : graph.colors.disabled;
        ctx.beginPath();
        ctx.moveTo(130+220*1-40,150+220*0+40);//  2:三
        ctx.lineTo(130+220*1+40,150+220*0+40);
        ctx.lineTo(130+220*1+40,150+220*0-40);
        ctx.lineTo(130+220*1-40,150+220*0+40);
        ctx.stroke();
        ctx.strokeStyle = 2<=Math.ceil(cdata.maxlevel/12)-1 ? graph.colors.main : graph.colors.disabled;
        ctx.beginPath();
        ctx.moveTo(130+220*2-40,150+220*0+40);//  3:絶
        ctx.lineTo(130+220*2-40,150+220*0-40);
        ctx.moveTo(130+220*2+40,150+220*0+40);
        ctx.lineTo(130+220*2+40,150+220*0-40);
        ctx.stroke();
        ctx.strokeStyle = 3<=Math.ceil(cdata.maxlevel/12)-1 ? graph.colors.main : graph.colors.disabled;
        ctx.beginPath();
        ctx.moveTo(130+220*3-40,150+220*0+0);//  4:指
        ctx.lineTo(130+220*3+0,150+220*0-40);
        ctx.lineTo(130+220*3+40,150+220*0+0);
        ctx.stroke();
        ctx.strokeStyle = 4<=Math.ceil(cdata.maxlevel/12)-1 ? graph.colors.main : graph.colors.disabled;
        ctx.beginPath();
        ctx.moveTo(130+220*0-40,150+220*1+40);//  5:高
        ctx.lineTo(130+220*0-40,150+220*1+0);
        ctx.lineTo(130+220*0+40,150+220*1+0);
        ctx.lineTo(130+220*0+40,150+220*1-40);
        ctx.stroke();
        ctx.strokeStyle = 5<=Math.ceil(cdata.maxlevel/12)-1 ? graph.colors.main : graph.colors.disabled;
        ctx.beginPath();
        ctx.moveTo(130+220*1-40,150+220*1+0);//  6:分
        ctx.lineTo(130+220*1+0,150+220*1+40);
        ctx.moveTo(130+220*1+0,150+220*1-40);
        ctx.lineTo(130+220*1+40,150+220*1+0);
        ctx.stroke();
        ctx.strokeStyle = 6<=Math.ceil(cdata.maxlevel/12)-1 ? graph.colors.main : graph.colors.disabled;
        ctx.beginPath();
        ctx.moveTo(130+220*2-40,150+220*1+40);//  7:斜
        ctx.lineTo(130+220*2+0,150+220*1+40);
        ctx.lineTo(130+220*2+40,150+220*1-40);
        ctx.lineTo(130+220*2+0,150+220*1-40);
        ctx.lineTo(130+220*2-40,150+220*1+40);
        ctx.stroke();
        ctx.strokeStyle = 7<=Math.ceil(cdata.maxlevel/12)-1 ? graph.colors.main : graph.colors.disabled;
        ctx.beginPath();
        ctx.moveTo(130+220*3-40,150+220*1+40);//  8:断
        ctx.lineTo(130+220*3+0,150+220*1+40);
        ctx.moveTo(130+220*3+0,150+220*1-40);
        ctx.lineTo(130+220*3+40,150+220*1-40);
        ctx.stroke();
        ctx.strokeStyle = 8<=Math.ceil(cdata.maxlevel/12)-1 ? graph.colors.main : graph.colors.disabled;
        ctx.beginPath();
        ctx.moveTo(130+220*0+40,150+220*2+40);//  9:極
        ctx.lineTo(130+220*0-40,150+220*2+40);
        ctx.lineTo(130+220*0+0,150+220*2-40);
        ctx.stroke();
      }
      else if(graph.type == "levels"){
        //  レベル選択
        //  ボタンの枠
        ctx.lineWidth = 15;
        ctx.font = "160px Inconsolata";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        for(let y=0; y<3; y++){
          for(let x=0; x<4; x++){
            ctx.strokeStyle = x+y*4<=cdata.maxlevel-Math.floor((level-1)/12)*12-1 ? graph.colors.main : graph.colors.disabled;
            ctx.fillStyle = x+y*4<=cdata.maxlevel-Math.floor((level-1)/12)*12-1 ? graph.colors.main_ : graph.colors.disabled_;
            ctx.fillRect(50+220*x,70+220*y,160,160);
            if(cdata.analog)ctx.shadowBlur = 10;
            ctx.strokeRect(50+220*x,70+220*y,160,160);
            ctx.shadowBlur = 0;
            if(x+y*4 === vars[0].value-1+(vars[1].value-1)*4){
              ctx.fillRect(50+220*x,70+220*y,160,160);
              ctx.fillRect(50+220*x,70+220*y,160,160);
              if(cdata.analog)ctx.shadowBlur = 10;
              ctx.strokeRect(50+220*x-10,70+220*y-10,160+20,160+20);
              ctx.shadowBlur = 0;
            }
            ctx.fillStyle = x+y*4<=cdata.maxlevel-Math.floor((level-1)/12)*12-1 ? graph.colors.main : graph.colors.disabled;
            if(cdata.analog)ctx.shadowBlur = 10;
            ctx.fillText((x+y*4+1).toString(16).toUpperCase(),130+220*x,150+220*y);
            ctx.shadowBlur = 0;
          }
        }
      }
      else if(graph.type == "explicit"){
        //  陽関数
        let p = problems[level];
        let x,y;

        //  グラフ  折れ線描画法
        if(cdata.analog)ctx.shadowBlur = 10;
        let c;
        if(!problems[level].hide){
          //  ヒント部分
          ctx.strokeStyle = graph.colors.main;
          ctx.lineWidth = 5;
          ctx.setLineDash([15,15]);
          ctx.beginPath();
          for(let i=-10; i<=930; i+=3){
            x = (i-graph.yaxis)/graph.scale;
            if(Number.isNaN(graph.func(x,p.answer[0],p.answer[1],p.answer[2],p.answer[3]))){
              c = {bool:false,x:x,d:3/graph.scale}
            }else{
              c = isContinuous(
                (x)=>graph.func(x,p.answer[0],p.answer[1],p.answer[2],p.answer[3]),
                x,3/graph.scale
              );
            }
            if(c.bool){
              y = graph.func(x,p.answer[0],p.answer[1],p.answer[2],p.answer[3]);
              y = -y*graph.scale+graph.xaxis;
              y = Math.min(Math.max(y,-10),750);
              ctx.lineTo(i,y);
            }
            else{
              y = graph.func(c.x,p.answer[0],p.answer[1],p.answer[2],p.answer[3]);
              y = -y*graph.scale+graph.xaxis;
              y = Math.min(Math.max(y,-10),750);
              ctx.lineTo(i,y);
              ctx.stroke();
              y = graph.func(c.x+c.d,p.answer[0],p.answer[1],p.answer[2],p.answer[3]);
              y = -y*graph.scale+graph.xaxis;
              y = Math.min(Math.max(y,-10),750);
              ctx.beginPath();
              ctx.moveTo(i,y);
            }
          }
          ctx.stroke();
        }
        if(problems[level].tangent){
          //  接線
          ctx.strokeStyle = graph.colors.hint;
          ctx.lineWidth = 5;
          ctx.setLineDash([15,15,45,15]);
          ctx.beginPath();
          for(let i=-10; i<=930; i+=3){
            x = (i-graph.yaxis)/graph.scale;
            if(Number.isNaN(p.funcTangent(x,p.answer[0],p.answer[1],p.answer[2],p.answer[3]))){
              c = {bool:false,x:x,d:3/graph.scale}
            }else{
              c = isContinuous(
                (x)=>p.funcTangent(x,p.answer[0],p.answer[1],p.answer[2],p.answer[3]),
                x,3/graph.scale
              );
            }
            if(c.bool){
              y = p.funcTangent(x,p.answer[0],p.answer[1],p.answer[2],p.answer[3]);
              y = -y*graph.scale+graph.xaxis;
              y = Math.min(Math.max(y,-10),750);
              ctx.lineTo(i,y);
            }
            else{
              y = p.funcTangent(c.x,p.answer[0],p.answer[1],p.answer[2],p.answer[3]);
              y = -y*graph.scale+graph.xaxis;
              y = Math.min(Math.max(y,-10),750);
              ctx.lineTo(i,y);
              ctx.stroke();
              y = p.funcTangent(c.x+c.d,p.answer[0],p.answer[1],p.answer[2],p.answer[3]);
              y = -y*graph.scale+graph.xaxis;
              y = Math.min(Math.max(y,-10),750);
              ctx.beginPath();
              ctx.moveTo(i,y);
            }
          }
          ctx.stroke();
        }
        if(problems[level].tangent2){
          //  接線2
          ctx.strokeStyle = graph.colors.hint;
          ctx.lineWidth = 5;
          ctx.setLineDash([15,15,45,15]);
          ctx.beginPath();
          for(let i=-10; i<=930; i+=3){
            x = (i-graph.yaxis)/graph.scale;
            if(Number.isNaN(p.funcTangent2(x,p.answer[0],p.answer[1],p.answer[2],p.answer[3]))){
              c = {bool:false,x:x,d:3/graph.scale}
            }else{
              c = isContinuous(
                (x)=>p.funcTangent2(x,p.answer[0],p.answer[1],p.answer[2],p.answer[3]),
                x,3/graph.scale
              );
            }
            if(c.bool){
              y = p.funcTangent2(x,p.answer[0],p.answer[1],p.answer[2],p.answer[3]);
              y = -y*graph.scale+graph.xaxis;
              y = Math.min(Math.max(y,-10),750);
              ctx.lineTo(i,y);
            }
            else{
              y = p.funcTangent2(c.x,p.answer[0],p.answer[1],p.answer[2],p.answer[3]);
              y = -y*graph.scale+graph.xaxis;
              y = Math.min(Math.max(y,-10),750);
              ctx.lineTo(i,y);
              ctx.stroke();
              y = p.funcTangent2(c.x+c.d,p.answer[0],p.answer[1],p.answer[2],p.answer[3]);
              y = -y*graph.scale+graph.xaxis;
              y = Math.min(Math.max(y,-10),750);
              ctx.beginPath();
              ctx.moveTo(i,y);
            }
          }
          ctx.stroke();
        }
        if(1){
          //  可動グラフ部分
          //  不連続点の取り扱い!!!
          seq = [];
          ctx.strokeStyle = graph.colors.main;
          ctx.lineWidth = 10;
          ctx.setLineDash([]);
          ctx.beginPath();
          for(let i=-10; i<=930; i+=3){
            x = (i-graph.yaxis)/graph.scale;
            if(Number.isNaN(graph.func(x,vars[0].value,vars[1].value,vars[2].value,vars[3].value))){
              c = {bool:false,x:x,d:3/graph.scale}
            }else{
              c = isContinuous(
                (x)=>graph.func(x,vars[0].value,vars[1].value,vars[2].value,vars[3].value),
                x,3/graph.scale
              );
            }
            if(c.bool){
              y = graph.func(x,vars[0].value,vars[1].value,vars[2].value,vars[3].value);
              y = -y*graph.scale+graph.xaxis;
              y = Math.min(Math.max(y,-10),750);
              ctx.lineTo(i,y);
            }
            else{
              y = graph.func(c.x,vars[0].value,vars[1].value,vars[2].value,vars[3].value);
              y = -y*graph.scale+graph.xaxis;
              y = Math.min(Math.max(y,-10),750);
              ctx.lineTo(i,y);
              ctx.stroke();
              y = graph.func(c.x+c.d,vars[0].value,vars[1].value,vars[2].value,vars[3].value);
              y = -y*graph.scale+graph.xaxis;
              y = Math.min(Math.max(y,-10),750);
              ctx.beginPath();
              ctx.moveTo(i,y);
            }
          }
          ctx.stroke();
        }

        //  通過する点
        if(problems[level].points){
          ctx.lineWidth = 10;
          ctx.strokeStyle = graph.colors.main;
          for(let i=0; i<problems[level].points.length; i++){
            x = problems[level].points[i];
            y = graph.func(x,problems[level].answer[0],problems[level].answer[1],problems[level].answer[2],problems[level].answer[3]);
            ctx.beginPath();
            ctx.arc(x*graph.scale+graph.yaxis,-y*graph.scale+graph.xaxis,10,0,Math.PI*2);
            ctx.stroke();
          }
        }

        //  式の表示
        //  影を落とす!!!
        let strs0,strs1,chars,x0,w0,w1,w;
        x = 40;
        ctx.strokeStyle = graph.colors.main;
        ctx.setLineDash([]);
        ctx.lineWidth = 5;
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";
        if(p.funcstr.match(/F/)){//  分数を含むとき
          strs0 = p.funcstr.match(/F\{[^\}]*\}\{[^\}]*\}|[^F]+/g);//  分数部分または一般部分
          ctx.clearRect(20,20,40,170);
          for(let i=0; i<strs0.length; i++){
            if(strs0[i].match(/F/)){//  分数部分
              strs1 = strs0[i].match(/(?<={)[^\}]*(?=})/g);//  [分子,分母]
              ctx.font = "60px Inconsolata";
              w0 = ctx.measureText(strs1[0].replace(/\^.|#./g,"")).width;
              w1 = ctx.measureText(strs1[1].replace(/\^.|#./g,"")).width;
              ctx.font = "75px Inconsolata";
              w0 += ctx.measureText(strs1[0].replace(/[^#]/g,"")).width;
              w1 += ctx.measureText(strs1[1].replace(/[^#]/g,"")).width;
              ctx.font = "40px Inconsolata";
              w0 += ctx.measureText(strs1[0].replace(/[^^]/g,"")).width;
              w1 += ctx.measureText(strs1[1].replace(/[^^]/g,"")).width;
              w = Math.max(w0,w1);
              ctx.clearRect(x,20,w+40,170);
              x0 = x+20;
              ctx.beginPath();
              ctx.moveTo(x+10,100);
              ctx.lineTo(x+w+30,100);
              ctx.stroke();
              //  分子の描画
              x = x0+(w-w0)/2;
              chars = strs1[0].match(/[\^\#]?./g);
              for(let j=0; j<chars.length; j++){
                if(chars[j].match(/\^/)){
                  chars[j] = chars[j].replace("^","");
                  y = 60;
                  ctx.font = "40px Inconsolata";
                }else if(chars[j].match(/\#/)){
                  chars[j] = chars[j].replace("#","");
                  y = 65;
                  ctx.font = "75px Inconsolata";
                }else{
                  y = 70;
                  ctx.font = "60px Inconsolata";
                }
                ctx.fillStyle = graph.colors.main;
                ctx.fillText(chars[j],x,y);
                x += ctx.measureText(chars[j]).width;
              }
              //  分母の描画
              x = x0+(w-w1)/2;
              chars = strs1[1].match(/[\^\#]?./g);
              for(let j=0; j<chars.length; j++){
                if(chars[j].match(/\^/)){
                  chars[j] = chars[j].replace("^","");
                  y = 60+70;
                  ctx.font = "40px Inconsolata";
                }else if(chars[j].match(/\#/)){
                  chars[j] = chars[j].replace("#","");
                  y = 65+70;
                  ctx.font = "75px Inconsolata";
                }else{
                  y = 70+70;
                  ctx.font = "60px Inconsolata";
                }
                ctx.fillStyle = graph.colors.main;
                ctx.fillText(chars[j],x,y);
                x += ctx.measureText(chars[j]).width;
              }
              x = x0+w+20;
            }
            else{//  一般部分
              chars = strs0[i].match(/[\^\#\$]?./g);
              ctx.font = "60px Inconsolata";
              w = ctx.measureText("|").width;//  普通のフォントの横幅
              for(let j=0; j<chars.length; j++){
                if(chars[j].match(/\^/)){
                  chars[j] = chars[j].replace("^","");
                  y = 60+35;
                  ctx.font = "40px Inconsolata";//  一回り小さい
                }else if(chars[j].match(/\#/)){
                  chars[j] = chars[j].replace("#","");
                  y = 65+35;
                  ctx.font = "75px Inconsolata";//  大きめ
                }else if(chars[j].match(/\$/)){
                  chars[j] = chars[j].replace("$","");
                  y = 65+35;
                  ctx.font = "150px Inconsolata";//  一回り大きい
                }else{
                  y = 70+35;
                  ctx.font = "60px Inconsolata";//  普通
                }
                ctx.clearRect(x,20,ctx.measureText(chars[j]).width,180);
                ctx.fillStyle = graph.colors.main;
                ctx.fillText(chars[j],x,y,w);
                x += Math.min(ctx.measureText(chars[j]).width,w);
              }
            }
          }
          ctx.clearRect(x,20,20,170);
          ctx.strokeRect(20,20,x,170);
          ctx.fillStyle = graph.colors.main_;
          ctx.shadowBlur = 0;
          ctx.fillRect(20,20,x,170);
        }
        else{//  分数を含まないとき
          ctx.clearRect(20,20,40,100);
          chars = p.funcstr.match(/[\^\#]?./g);
          for(let i=0; i<chars.length; i++){
            if(chars[i].match(/\^/)){
              chars[i] = chars[i].replace("^","");
              y = 60;
              ctx.font = "40px Inconsolata";
            }else if(chars[i].match(/\#/)){
              chars[i] = chars[i].replace("#","");
              y = 65;
              ctx.font = "75px Inconsolata";
            }else{
              y = 70;
              ctx.font = "60px Inconsolata";
            }
            ctx.clearRect(x,20,ctx.measureText(chars[i]).width,100);
            ctx.fillStyle = graph.colors.main;
            ctx.fillText(chars[i],x,y);
            x += ctx.measureText(chars[i]).width;
          }
          ctx.clearRect(x,20,20,100);
          ctx.strokeRect(20,20,x,100);
          ctx.fillStyle = graph.colors.main_;
          ctx.shadowBlur = 0;
          ctx.fillRect(20,20,x,100);
        }
      }

      //  クリアメッセージ
      if(clear){
        if(cdata.analog)ctx.shadowBlur = 10;
        ctx.fillStyle = "#000000c0";
        ctx.fillRect(-10,-10,940,760);
        let txt = "LEVEL ";
        txt += `${(Math.floor((level-1)/12)+1).toString(16).toUpperCase()}-`;
        txt += `${((level-1)%12+1).toString(16).toUpperCase()}`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = graph.colors.message_;
        ctx.strokeStyle = graph.colors.message;
        ctx.lineWidth = 5;
        ctx.font = "160px Inconsolata";
        ctx.fillText(`${txt}`,460,200);
        ctx.strokeText(`${txt}`,460,200);
        ctx.font = "300px Inconsolata";
        ctx.fillText(`CLEAR!`,460,500);
        ctx.strokeText(`CLEAR!`,460,500);
      }

      ctx.restore();
    }

    function DrawControls(){
      //  スライダー
      ctx.lineWidth = 10;
      ctx.strokeStyle = "#888";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      for(let i=0; i<4; i++){
        ctx.beginPath();
        ctx.moveTo(200,925+i*130);
        ctx.lineTo(200,975+i*130);
        ctx.moveTo(800,925+i*130);
        ctx.lineTo(800,975+i*130);
        ctx.moveTo(200,950+i*130);
        ctx.lineTo(800,950+i*130);
        ctx.stroke();
        //  上限と下限
        ctx.fillStyle = "#000";
        ctx.fillRect(40,910+i*130,100,80);
        ctx.fillRect(860,910+i*130,100,80);
        ctx.fillStyle = "#f00";
        ctx.font = "80px Inconsolata";
        ctx.fillText(vars[i].available ? vars[i].min : "",90,950+i*130,80);
        ctx.fillText(vars[i].available ? vars[i].max : "",910,950+i*130,80);
        //  可動部
        ctx.fillStyle = "#333";
        ctx.beginPath();
        ctx.arc(vars[i].proportion*600+200,950+i*130,30,0,Math.PI*2);
        ctx.fill();
        ctx.fillStyle = vars[i].available ? "#8f8" : "#888";
        ctx.beginPath();
        ctx.arc(vars[i].proportion*600+200,950+i*130,25,0,Math.PI*2);
        ctx.fill();
        ctx.fillStyle = "#333";
        ctx.font = "50px Inconsolata";
        ctx.fillText("abcd"[i],vars[i].proportion*600+200,950+i*130);
      }



      //  ボタン
      ctx.lineWidth = 5;
      ctx.strokeStyle = "#333";
      //  prevボタン
      ctx.fillStyle = buttons.prev.available ? "#8f8" : "#888";
      ctx.fillRect(40,1510,280,100);
      ctx.beginPath();
      ctx.moveTo(40,1610);
      ctx.lineTo(320,1610);
      ctx.lineTo(320,1510);
      ctx.lineTo(40,1510);
      ctx.closePath();
      ctx.stroke();
      //  resetボタン
      ctx.fillStyle = buttons.reset.available ? "#8f8" : "#888";
      ctx.fillRect(40+320,1510,280,100);
      ctx.beginPath();
      ctx.moveTo(40+320,1610);
      ctx.lineTo(320+320,1610);
      ctx.lineTo(320+320,1510);
      ctx.lineTo(40+320,1510);
      ctx.closePath();
      ctx.stroke();
      //  nextボタン
      ctx.fillStyle = buttons.next.available ? "#8f8" : "#888";
      ctx.fillRect(40+640,1510,280,100);
      ctx.beginPath();
      ctx.moveTo(40+640,1610);
      ctx.lineTo(320+640,1610);
      ctx.lineTo(320+640,1510);
      ctx.lineTo(40+640,1510);
      ctx.closePath();
      ctx.stroke();
      //  各ボタンの表示部
      ctx.fillStyle = "#333";
      ctx.font = "100px Inconsolata";
      ctx.fillText("PREV",180,1560);
      ctx.fillText("RESET",180+320,1560);
      ctx.fillText("NEXT",180+640,1560);
    }

    function isContinuous(f,x,d){
      if(Math.min(f(x),f(x+d))<f(x+d/2)&&f(x+d/2)<Math.max(f(x),f(x+d))){
        //  連続とみなす
        return {bool:true};
      }
      else if(Math.abs(Math.atan2(f(x+d/2)-f(x),d/2) - Math.atan2(f(x+d)-f(x+d/2),d/2))<.0001){
        //  連続とみなす
        return {bool:true};
      }
      else{
        if(d<.000001)return {bool:false,x:x,d:d};
        //  不連続かもしれない
        let c0 = isContinuous(f,x,d/2);
        let c1 = isContinuous(f,x+d/2,d/2);
        if(c0.bool&&c1.bool){
          return {bool:true};
        }else{
          let c = c0.bool ? c1 : c0;
          return {bool:false,x:c.x,d:c.d};
        }
      }
    }

    //  (x,y)が矩形内にあるかどうか
    function IsIn(x,y,x0,y0,w,h){
      let bool = 1;
      bool = bool && x0 < x;
      bool = bool && x < x0+w;
      bool = bool && y0 < y;
      bool = bool && y < y0+h;
      return bool;
    }

    //  滑らかに変化する値を返す
    //  t=0 => a
    //  t=1 => b
    //  t=2 => c
    function Smooth(t,a,b,c){
      if(t<0 || 2<t){
        console.error("Unexpected value");
      }else if(t<1){
        return a+(b-a)/2*(1-Math.cos(Math.PI*t));
      }else{
        return b+(c-b)/2*(1+Math.cos(Math.PI*t));
      }
    }











  </script>
  <script type="text/javascript">alert("script ended!");</script>
</html>
