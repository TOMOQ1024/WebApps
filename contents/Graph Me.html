<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
    <title>Graph Me</title>
    <link rel="stylesheet" href="Style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inconsolata&display=swap" rel="stylesheet">
    <style>
      *{
        font-size: 0;
        overflow: hidden;
        display: inline-block;
        text-align: center;
      }

      @font-face
      {
        font-family: 'Inconsolata';
        font-style: normal;
        font-weight: 100;
        src: url('mplus1p-thin.eot');  /* IE9+ */
        src: url('mplus1p-thin.eot?#iefix') format('embedded-opentype'),  /* IE8- */
             url('mplus1p-thin.woff') format('woff'),     /* その他のブラウザ */
             url('mplus1p-thin.ttf') format('truetype');  /* 古いiOS */
      }
    </style>
  </head>
  <body>
    <div id="wrapper">
      <canvas id="main_canvas" width="1000" height="1650"></canvas>
    </div>
  </body>
  <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
  <script type="text/javascript">
    //


    /*

    使用フォント:Inconsolata(Google fonts)
    https://fonts.google.com/specimen/Inconsolata?query=inconsola#standard-styles

    フォントのロードの検知:Web Font Loader
    参考:http://ithat.me/2016/12/10/js-web-font-load-start-complete-detection-web-font-loader
    */



    let Sleep = ms => new Promise(r=>setTimeout(r,ms));
    let cvs,ctx,touches,buttons,vars,graph,ctrl,level,maxlevel,clear;
    //  難易度順に入れ替える!!!
    let problems = {
      0 : {
        type : "title",
        xaxis : 370,//  0...740
        yaxis : 460,//  0...920
        gscale : 175/2,//  グラフの目盛
        vars : [0,0,1,0],//  各変数を使用するかどうか
        min : [-1,-1,-1,-1],//  最小値
        value : [0,0,-.7,0],//  初期値
        max : [1,1,1,1],//  最大値
        vscale : [0,0,0,0],//  変数値の目盛
        answer : [0,0,0,0]//  各変数の解答値
      },
      1 : {
        type : "explicit",
        funcstr : "y=a",
        func : (x,a,b,c,d) => {
          return a;
        },
        xaxis : 550,
        yaxis : 460,
        gscale : 60,
        vars : [1,0,0,0],
        min : [-10,-1,-1,-1],
        value : [0,0,0,0],
        max : [10,1,1,1],
        vscale : [0,0,0,0],
        answer : [4,0,0,0]
      },
      2 : {
        type : "explicit",
        funcstr : "y=ax+b",
        func : (x,a,b,c,d) => {
          return a*x+b;
        },
        xaxis : 550,
        yaxis : 460,
        gscale : 60,
        vars : [1,1,0,0],
        min : [-10,-10,-1,-1],
        value : [0,0,0,0],
        max : [10,10,1,1],
        vscale : [0,0,0,0],
        answer : [3,-2,0,0]
      },
      3 : {
        type : "explicit",
        funcstr : "y=a(x-2)+b",
        func : (x,a,b,c,d) => {
          return a*(x-2)+b;
        },
        xaxis : 550,
        yaxis : 320,
        gscale : 60,
        vars : [1,1,0,0],
        min : [-3,-10,-1,-1],
        value : [0,0,0,0],
        max : [3,10,1,1],
        vscale : [0,0,0,0],
        answer : [.5,2,0,0]
      },
      4 : {
        type : "explicit",
        funcstr : "y=a(bx+1)",
        func : (x,a,b,c,d) => {
          return a*(b*x+1);
        },
        xaxis : 200,
        yaxis : 460,
        gscale : 60,
        vars : [1,1,0,0],
        min : [-10,-1,-1,-1],
        value : [0,0,0,0],
        max : [3,1,1,1],
        vscale : [0,0,0,0],
        answer : [-6,.25,0,0]
      },
      5 : {
        type : "explicit",
        funcstr : "y=ax^2+b",
        func : (x,a,b,c,d) => {
          return a*x*x+b;
        },
        xaxis : 370,
        yaxis : 460,
        gscale : 60,
        vars : [1,1,0,0],
        min : [-1,-5,-1,-1],
        value : [0,0,0,0],
        max : [1,5,1,1],
        vscale : [0,0,0,0],
        answer : [-.25,3,0,0]
      },
      6 : {
        type : "explicit",
        funcstr : "y=a(x-b)^2+c",
        func : (x,a,b,c,d) => {
          return a*(x-b)**2+c;
        },
        xaxis : 370,
        yaxis : 460,
        gscale : 60,
        vars : [1,1,1,0],
        min : [-3,-10,-10,-1],
        value : [0,0,0,0],
        max : [3,10,10,1],
        vscale : [0,0,0,0],
        answer : [.5,3,-2,0]
      },
      7 : {
        type : "explicit",
        funcstr : "y=a(x-b)(x-c)",
        func : (x,a,b,c,d) => {
          return a*(x-b)*(x-c);
        },
        xaxis : 370,
        yaxis : 460,
        gscale : 60,
        vars : [1,1,1,0],
        min : [-1,-5,-10,-1],
        value : [0,0,0,0],
        max : [1,5,10,1],
        vscale : [0,0,0,0],
        answer : [.125,3,-6,0]
      },
      8 : {
        type : "explicit",
        funcstr : "y=ax(x-b)+c",
        func : (x,a,b,c,d) => {
          return a*x*(x-b)+c;
        },
        xaxis : 370,
        yaxis : 460,
        gscale : 60,
        vars : [1,1,1,0],
        min : [-1,-10,-10,-1],
        value : [0,0,0,0],
        max : [1,10,10,1],
        vscale : [0,0,0,0],
        answer : [-.25,4,3,0]
      },
      9 : {
        type : "explicit",
        hide : 1,
        tangent : 1,
        funcstr : "y=0.25x^2+a",
        func : (x,a,b,c,d) => {
          return x*x/4+a;
        },
        funcTangent : (x,a,b,c,d)=>{
          return x-5;
        },
        xaxis : 370,
        yaxis : 460,
        gscale : 60,
        vars : [1,0,0,0],
        min : [-10,-10,-10,-1],
        value : [0,0,0,0],
        max : [10,10,10,1],
        vscale : [0,0,0,0],
        answer : [-4,4,3,0]
      },
      10 : {
        type : "explicit",
        hide : 1,
        points : [4],
        tangent : 1,
        funcstr : "y=ax^2+abx",
        func : (x,a,b,c,d) => {
          return a*x*x+a*b*x;
        },
        funcTangent : (x,a,b,c,d)=>{
          return x-4;
        },
        xaxis : 500,
        yaxis : 300,
        gscale : 60,
        vars : [1,1,0,0],
        min : [-1,-5,-10,-1],
        value : [0,0,0,0],
        max : [1,5,10,1],
        vscale : [0,0,0,0],
        answer : [.25,-4,3,0]
      },
      11 : {
        type : "explicit",
        hide : 1,
        points : [0,4],
        tangent : 1,
        funcstr : "y=a(x^2-b)",
        func : (x,a,b,c,d) => {
          return a*(x*x-b);
        },
        funcTangent : (x,a,b,c,d)=>{
          return -5;
        },
        xaxis : 400,
        yaxis : 400,
        gscale : 60,
        vars : [1,1,0,0],
        min : [-1,-5,-10,-1],
        value : [0,0,0,0],
        max : [1,10,10,1],
        vscale : [0,0,0,0],
        answer : [.5,10,3,0]
      },
      12 : {
        type : "explicit",
        hide : 1,
        points : [-3,1,5],
        tangent : 0,
        funcstr : "y=ax^2+bx+c",
        func : (x,a,b,c,d) => {
          return a*x*x+b*x+c;
        },
        funcTangent : (x,a,b,c,d)=>{
          return -5;
        },
        xaxis : 400,
        yaxis : 400,
        gscale : 60,
        vars : [1,1,1,0],
        min : [-1,-1,-5,-1],
        value : [0,0,0,0],
        max : [1,1,5,1],
        vscale : [0,0,0,0],
        answer : [.25,-.5,-3.75,0]
      },
      13 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        funcstr : "y=asin(x)+b",
        func : (x,a,b,c,d) => {
          return a*Math.sin(x)+b;
        },
        funcTangent : (x,a,b,c,d)=>{
          return -5;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,0,0],
        min : [-5,-5,-5,-1],
        value : [0,0,0,0],
        max : [5,5,5,1],
        vscale : [0,0,0,0],
        answer : [3,-2,-3.75,0]
      },
      14 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        funcstr : "y=acos(bx)+c",
        func : (x,a,b,c,d) => {
          return a*Math.cos(b*x)+c;
        },
        funcTangent : (x,a,b,c,d)=>{
          return -5;
        },
        xaxis : 450,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,0],
        min : [-5,0,-5,-1],
        value : [0,0,0,0],
        max : [5,5,5,1],
        vscale : [0,0,0,0],
        answer : [2,5,1,0]
      },
      15 : {
        type : "explicit",
        hide : 0,
        points : [],
        tangent : 0,
        funcstr : "y=atan(bx)+c",
        func : (x,a,b,c,d) => {
          return a*Math.tan(b*x)+c;
        },
        funcTangent : (x,a,b,c,d)=>{
          return -5;
        },
        xaxis : 500,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,0],
        min : [-2,0,-5,-1],
        value : [0,0,0,0],
        max : [2,5,5,1],
        vscale : [0,0,0,0],
        answer : [-1,.5,3,0]
      },
      16 : {
        type : "explicit",
        hide : 1,
        points : [0],
        tangent : 1,
        funcstr : "y=asin(x-b)",
        func : (x,a,b,c,d) => {
          return a*Math.sin(x-b);
        },
        funcTangent : (x,a,b,c,d)=>{
          return -3;
        },
        xaxis : 370,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,0,0],
        min : [0,-2,-5,-1],
        value : [0,1,0,0],
        max : [5,2,5,1],
        vscale : [0,0,0,0],
        answer : [3,0,3,0]
      },
      17 : {
        type : "explicit",
        hide : 1,
        points : [0],
        tangent : 1,
        tangent2 : 1,
        funcstr : "y=asin(x-b)+c",
        func : (x,a,b,c,d) => {
          return a*Math.sin(x-b)+c;
        },
        funcTangent : (x,a,b,c,d)=>{
          return -1;
        },
        funcTangent2 : (x,a,b,c,d)=>{
          return -7;
        },
        xaxis : 100,//370
        yaxis : 460,//460
        gscale : 60,
        vars : [1,1,1,0],
        min : [0,0,-5,-1],
        value : [0,0,0,0],
        max : [5,5,5,1],
        vscale : [0,0,0,0],
        answer : [3,4,-4,0]
      }
    };




    //  マウス対応!!!
    //  フォントの読み込み後に開始
    WebFont.load({
      custom : {
        families : ["Inconsolata"]
      },
      active : () => {
        Init();

        //  リサイズ時, canvasを画面の大きさに合わせる
        window.onresize = () => {Resize();}
        //  操作
        if(window.ontouchstart === null){
          //  タッチ操作
          cvs.ontouchstart = (e) => {
            if(!ctrl)return 0;
            e.preventDefault();
            let x = e.touches[0].clientX-cvs.getBoundingClientRect().left;//  canvas左上からのpx値
            let y = e.touches[0].clientY-cvs.getBoundingClientRect().top;
            let wp = cvs.width;
            let wr = cvs.getBoundingClientRect().width;
            let hp = cvs.height;
            let hr = cvs.getBoundingClientRect().height;
            let r = window.innerWidth/20;

            //  スライダーの判定
            for(let i=0; i<4; i++){
              ctx.fillStyle = "#ff00ff20";
              ctx.fillRect(vars[i].proportion*600+200-50,950+i*130-50,100,100);
              if(IsIn(x,y,(vars[i].proportion*600+200)/wp*wr-r,(950+i*130)/wp*wr-r,r*2,r*2)){//  canvas内の点の座標を戻す
                buttons.slider = i;
                break;
              }
            }

            //  ボタンの判定
            if(IsIn(x,y,40/wp*wr,1510/wp*wr,280/wp*wr,100/wp*wr)&&buttons.prev.available){
              Prev();
            };
            if(IsIn(x,y,360/wp*wr,1510/wp*wr,280/wp*wr,100/wp*wr)&&buttons.reset.available){
              Reset();
            };
            if(IsIn(x,y,680/wp*wr,1510/wp*wr,280/wp*wr,100/wp*wr)&&buttons.next.available){
              Next();
            };

            //  タッチ操作は一つのみ有効
            ctrl = 0;
            DrawAll();
          }
          cvs.ontouchmove = (e) => {
            e.preventDefault();
            let x = e.touches[0].clientX-cvs.getBoundingClientRect().left;
            x *= cvs.width;
            x /= cvs.getBoundingClientRect().width;
            let v;

            //  スライダー操作
            if(0<=buttons.slider){
              v = vars[buttons.slider];
              v.value = (v.max-v.min)*Math.min(Math.max((x-200)/600,0),1)+v.min;
              v.adapt();
              SetButtons();
            }
            DrawAll();
          }
          cvs.ontouchend = () => {
            buttons.slider = -1;
            Check();
            ctrl = 1;
            DrawAll();
          }
        }else{
          //  マウス操作
        }
      },
      inactive : () => {
        alert("フォント読み込み失敗");
      }
    });

    function Resize(){
      let len = Math.min(window.innerWidth/20,window.innerHeight/33)*.95;
      cvs.style.width = `${len*20}px`;
    }

    function Init(){
      cvs = document.querySelector("#main_canvas");
      ctx = cvs.getContext("2d");
      ctx.lineJoin = "round";
      ctx.lineCap = "round";
      touches = {};
      buttons = {
        prev : {
          //down : 0,  ボタン押下時の見た目はそのままでよいのか!!!???
          available : 0
        },
        reset : {
          //down : 0,
          available : 0
        },
        next : {
          //down : 0,
          available : 0
        },
        slider : -1
      };
      vars = [];
      for(let i=0; i<4; i++){
        vars.push({});
        Object.defineProperty(vars[i],"proportion",{
          get : () => {
            let v = vars[i];
            return (v.value-v.min)/(v.max-v.min);
          }
        });
        Object.defineProperty(vars[i],"adapt",{
          value : () => {
            let v = vars[i];
            if(v.scale){
              v.value = v.scale*Math.round((v.value-v.min)/v.scale)+v.min;
            }
          }
        });
      }
      graph = {};
      ctrl = 1;
      level = 0;//  0はタイトル画面
      maxlevel = 1;
      clear = 0;//  レベルごとに使用. 0:未, 1:済

      //  Resetによる初期化
      Resize();
      Reset();
      UnlockAll();//  公開時は削除する
    }

    //  ボタン設定
    function SetButtons(){
      if(graph.type === "stages"){
        if(vars[0].value-1+(vars[1].value-1)*4<=Math.ceil(maxlevel/12)-1){
          //  nextボタン
          buttons.next.available = 1;
        }else{
          buttons.next.available = 0;
        }
        buttons.reset.available = 0;
      }
      else if(graph.type === "levels"){
        if(vars[0].value+(vars[1].value-1)*4<=maxlevel){
          //  nextボタン
          buttons.next.available = 1;
        }else{
          buttons.next.available = 0;
        }
        buttons.reset.available = 0;
      }
      else{
        buttons.prev.available = graph.type==="title" ? 0 : 1;
        buttons.reset.available = graph.type==="title" ? 0 : 1;
        buttons.next.available = graph.type==="title" ? 0 : +(level<maxlevel);
      }
    }

    //  クリア判定等
    function Check(){
      if(graph.type === "stages")return 0;
      if(graph.type === "levels")return 0;
      let bool = 1;
      for(let i=0; i<4; i++){
        if(!vars[i].available)continue;
        if(Math.abs(vars[i].value-problems[level].answer[i])>(vars[i].max-vars[i].min)/30){
          bool = 0;
        }
      }
      if(bool)Clear();
    }

    //  クリア後の処理
    async function Clear(){
      for(let i=0; i<4; i++){
        if(vars[i].available)
          vars[i].value = problems[level].answer[i];
      }
      if(clear)return 0;
      await Sleep(50);
      if(level === 0){
        //  タイトル画面クリア時の処理
        graph.type = "stages";
        buttons.prev.available = 1;
        DrawSelect();
      }
      else{
        //  レベルクリア時の処理
        maxlevel = Math.min(level+1,Object.keys(problems).reduce((a,b)=>Math.max(+a,+b)));
        SetButtons();
        clear = 1;
        DrawAll();
      }
    }

    function UnlockAll(){
      maxlevel = Object.keys(problems).reduce((a,b)=>Math.max(+a,+b));
      SetButtons();
      clear = 0;
      DrawAll();
    }

    function DrawSelect(b){
      //
      graph.scale = 55;
      vars[0].available = 1;
      vars[0].min = 1;
      vars[0].max = 4;
      vars[0].value = b ? ((level-1)%12)%4+1 : 1;
      vars[0].scale = 1;
      vars[1].available = 1;
      vars[1].min = 1;
      vars[1].max = 3;
      vars[1].value = b ? Math.floor(((level-1)%12)/4)+1 : 1;
      vars[1].scale = 1;
      vars[2].available = 0;
      SetButtons();
      DrawAll();
    }

    function Prev(){
      if(graph.type === "stages"){
        Init();
      }
      else if(graph.type === "levels"){
        graph.type = "stages";
        SetButtons();
        DrawAll();
      }
      else{
        //  任意のレベル
        graph.type = "levels";
        clear = 0;
        SetButtons();
        DrawSelect(1);
      }
    }

    //  問題画面の初期化. 最初の表示にも用いる.
    function Reset(){
      //  グラフの設定
      let p = problems[level];
      graph.type = p.type;
      graph.xaxis = p.xaxis;
      graph.yaxis = p.yaxis;
      graph.scale = p.gscale;
      graph.func = p.func;
      for(let i=0; i<4; i++){
        vars[i].available = p.vars[i];
        vars[i].min = p.min[i];
        vars[i].value = p.value[i];
        vars[i].max = p.max[i];
        vars[i].scale = p.vscale[i];
      }
      clear = 0;

      //  ボタンの設定
      SetButtons();

      DrawAll();
    }

    function Next(){
      if(graph.type === "stages"){
        graph.type = "levels";
        level = (vars[0].value-1+(vars[1].value-1)*4)*12+1;
        DrawSelect();
      }
      else if(graph.type === "levels"){
        level = Math.floor((level-1)/12)*12 + vars[0].value-1+(vars[1].value-1)*4 + 1;
        Reset();
      }
      else{
        level += 1;
        Reset();
      }
    }

    function DrawAll(){
      DrawBackground();
      DrawScreen();
      DrawControls();
    }

    function DrawBackground(){
      ctx.fillStyle = "#ccc";
      ctx.fillRect(0,0,cvs.width,cvs.height);
    }

    function DrawScreen(){
      ctx.save();

      //  描画範囲の指定
      ctx.beginPath();
      ctx.moveTo(40,40);
      ctx.lineTo(40,780);
      ctx.lineTo(960,780);
      ctx.lineTo(960,40);
      ctx.closePath();
      ctx.clip();

      //  背景
      ctx.fillStyle = "#000";
      ctx.fillRect(0,0,cvs.width,cvs.height);

      //  スクリーン左上を原点とする
      ctx.translate(40,40);

      //  グリッド
      ctx.strokeStyle = "#444";
      for(let i=Math.ceil(-graph.yaxis/graph.scale); i<=(920-graph.yaxis)/graph.scale; i++){
        ctx.lineWidth = i%5 ? 4 : 6;
        ctx.beginPath();
        ctx.moveTo(graph.yaxis+i*graph.scale,0);
        ctx.lineTo(graph.yaxis+i*graph.scale,740);
        ctx.stroke();
      }
      for(let i=Math.ceil(-graph.xaxis/graph.scale); i<=(740-graph.xaxis)/graph.scale; i++){
        ctx.lineWidth = i%5 ? 4 : 6;
        ctx.beginPath();
        ctx.moveTo(0,graph.xaxis+i*graph.scale);
        ctx.lineTo(920,graph.xaxis+i*graph.scale);
        ctx.stroke();
      }
      //  軸
      ctx.lineWidth = 8;
      ctx.strokeStyle = "#777";
      ctx.beginPath();
      ctx.moveTo(graph.yaxis,0);
      ctx.lineTo(graph.yaxis,740);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0,graph.xaxis);
      ctx.lineTo(920,graph.xaxis);
      ctx.stroke();

      //  グラフ
      if(graph.type == "title"){
        //  タイトル画面
        //  さらなる複雑化!!!
        ctx.strokeStyle = "#ff0";
        ctx.lineWidth = 10;

        ctx.beginPath();
        ctx.moveTo(460-175*2+60,370-175-140);//  G
        ctx.lineTo(460-175*2-60,370-175-140);
        ctx.lineTo(460-175*2-60,370-175+140);
        ctx.lineTo(460-175*2+60,370-175+140);
        ctx.lineTo(460-175*2+60,370-175+0);
        ctx.lineTo(460-175*2-0,370-175+0);
        ctx.moveTo(460-175*1-60,370-175+140);//  R
        ctx.lineTo(460-175*1-60,370-175-140);
        ctx.lineTo(460-175*1+60,370-175-140);
        ctx.lineTo(460-175*1+60,370-175-0);
        ctx.lineTo(460-175*1-60,370-175-0);
        ctx.moveTo(460-175*1+0,370-175-0);
        ctx.lineTo(460-175*1+60,370-175+140);
        ctx.moveTo(460-175*0-60,370-175+140);//  A
        ctx.lineTo(460-175*0-60,370-175-140);
        ctx.lineTo(460-175*0+60,370-175-140);
        ctx.lineTo(460-175*0+60,370-175+140);
        ctx.moveTo(460-175*0-60,370-175+0);
        ctx.lineTo(460-175*0+60,370-175+0);
        ctx.moveTo(460+175*1-60,370-175+140);//  P
        ctx.lineTo(460+175*1-60,370-175-140);
        ctx.lineTo(460+175*1+60,370-175-140);
        ctx.lineTo(460+175*1+60,370-175-0);
        ctx.lineTo(460+175*1-60,370-175-0);
        ctx.moveTo(460+175*2-60,370-175+140);//  H
        ctx.lineTo(460+175*2-60,370-175-140);
        ctx.moveTo(460+175*2-60,370-175+0);
        ctx.lineTo(460+175*2+60,370-175+0);
        ctx.moveTo(460+175*2+60,370-175+140);
        ctx.lineTo(460+175*2+60,370-175-140);
        ctx.translate(vars[2].value*175*2,-vars[2].value*175);//  cでずらす
        ctx.moveTo(460-175*0.5-60,370+175+140);//  可動M
        ctx.lineTo(460-175*0.5-60,370+175-140);
        ctx.lineTo(460-175*0.5+60,370+175-140);
        ctx.lineTo(460-175*0.5+60,370+175+140);
        ctx.moveTo(460-175*0.5+0,370+175-140);
        ctx.lineTo(460-175*0.5+0,370+175+140);
        ctx.translate(-vars[2].value*175*2,vars[2].value*175);//  ずれを戻す
        ctx.moveTo(460+175*0.5+60,370+175-140);//  G
        ctx.lineTo(460+175*0.5-60,370+175-140);
        ctx.lineTo(460+175*0.5-60,370+175+140);
        ctx.lineTo(460+175*0.5+60,370+175+140);
        ctx.moveTo(460+175*0.5-60,370+175+0);
        ctx.lineTo(460+175*0.5+60,370+175+0);
        ctx.stroke();
        ctx.lineWidth = 5;
        ctx.setLineDash([15,15]);
        ctx.beginPath();
        ctx.moveTo(460-175*0.5-60,370+175+140);//  不動M
        ctx.lineTo(460-175*0.5-60,370+175-140);
        ctx.lineTo(460-175*0.5+60,370+175-140);
        ctx.lineTo(460-175*0.5+60,370+175+140);
        ctx.moveTo(460-175*0.5+0,370+175-140);
        ctx.lineTo(460-175*0.5+0,370+175+140);
        ctx.stroke();
      }
      else if(graph.type == "stages"){
        //  ステージ選択
        //  ボタンの枠
        ctx.lineWidth = 15;
        for(let y=0; y<3; y++){
          for(let x=0; x<4; x++){
            ctx.strokeStyle = x+y*4<=Math.ceil(maxlevel/12)-1 ? "#ffff00" : "#888888";
            ctx.fillStyle = x+y*4<=Math.ceil(maxlevel/12)-1 ? "#ffff0040" : "#88888840";
            ctx.fillRect(50+220*x,70+220*y,160,160);
            ctx.strokeRect(50+220*x,70+220*y,160,160);
            if(x+y*4 === vars[0].value-1+(vars[1].value-1)*4){
              ctx.fillRect(50+220*x,70+220*y,160,160);
              ctx.fillRect(50+220*x,70+220*y,160,160);
              ctx.strokeRect(50+220*x-10,70+220*y-10,160+20,160+20);
            }
          }
        }
        //  ボタンのデザイン
        ctx.strokeStyle = "#ff0";
        ctx.strokeStyle = 0<=Math.ceil(maxlevel/12)-1 ? "#ffff00" : "#888888";
        ctx.beginPath();
        ctx.moveTo(130+220*0-40,150+220*0-40);//  1:礎
        ctx.lineTo(130+220*0+0,150+220*0+40);
        ctx.lineTo(130+220*0+40,150+220*0-40);
        ctx.stroke();
        ctx.strokeStyle = 1<=Math.ceil(maxlevel/12)-1 ? "#ffff00" : "#888888";
        ctx.beginPath();
        ctx.moveTo(130+220*1-40,150+220*0+40);//  2:三
        ctx.lineTo(130+220*1+40,150+220*0+40);
        ctx.lineTo(130+220*1+40,150+220*0-40);
        ctx.lineTo(130+220*1-40,150+220*0+40);
        ctx.stroke();
        ctx.strokeStyle = 2<=Math.ceil(maxlevel/12)-1 ? "#ffff00" : "#888888";
        ctx.beginPath();
        ctx.moveTo(130+220*2-40,150+220*0+0);//  3:指
        ctx.lineTo(130+220*2+0,150+220*0-40);
        ctx.lineTo(130+220*2+40,150+220*0+0);
        ctx.stroke();
        ctx.strokeStyle = 3<=Math.ceil(maxlevel/12)-1 ? "#ffff00" : "#888888";
        ctx.beginPath();
        ctx.moveTo(130+220*3-40,150+220*0+40);//  4:高
        ctx.lineTo(130+220*3-40,150+220*0+0);
        ctx.lineTo(130+220*3+40,150+220*0+0);
        ctx.lineTo(130+220*3+40,150+220*0-40);
        ctx.stroke();
        ctx.strokeStyle = 4<=Math.ceil(maxlevel/12)-1 ? "#ffff00" : "#888888";
        ctx.beginPath();
        ctx.moveTo(130+220*0-40,150+220*1+40);//  5:絶
        ctx.lineTo(130+220*0-40,150+220*1-40);
        ctx.moveTo(130+220*0+40,150+220*1+40);
        ctx.lineTo(130+220*0+40,150+220*1-40);
        ctx.stroke();
        ctx.strokeStyle = 5<=Math.ceil(maxlevel/12)-1 ? "#ffff00" : "#888888";
        ctx.beginPath();
        ctx.moveTo(130+220*1-40,150+220*1+40);//  6:斜
        ctx.lineTo(130+220*1+0,150+220*1+40);
        ctx.lineTo(130+220*1+40,150+220*1-40);
        ctx.lineTo(130+220*1+0,150+220*1-40);
        ctx.lineTo(130+220*1-40,150+220*1+40);
        ctx.stroke();
        ctx.strokeStyle = 6<=Math.ceil(maxlevel/12)-1 ? "#ffff00" : "#888888";
        ctx.beginPath();
        ctx.moveTo(130+220*2-40,150+220*1+0);//  7:分
        ctx.lineTo(130+220*2+0,150+220*1+40);
        ctx.moveTo(130+220*2+0,150+220*1-40);
        ctx.lineTo(130+220*2+40,150+220*1+0);
        ctx.stroke();
        ctx.strokeStyle = 7<=Math.ceil(maxlevel/12)-1 ? "#ffff00" : "#888888";
        ctx.beginPath();
        ctx.moveTo(130+220*3-40,150+220*1+40);//  8:断
        ctx.lineTo(130+220*3+0,150+220*1+40);
        ctx.moveTo(130+220*3+0,150+220*1-40);
        ctx.lineTo(130+220*3+40,150+220*1-40);
        ctx.stroke();
        ctx.strokeStyle = 8<=Math.ceil(maxlevel/12)-1 ? "#ffff00" : "#888888";
        ctx.beginPath();
        ctx.moveTo(130+220*0+40,150+220*2+40);//  9:極
        ctx.lineTo(130+220*0-40,150+220*2+40);
        ctx.lineTo(130+220*0+0,150+220*2-40);
        ctx.stroke();
      }
      else if(graph.type == "levels"){
        //  レベル選択
        //  ボタンの枠
        ctx.lineWidth = 15;
        ctx.font = "160px Inconsolata";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        for(let y=0; y<3; y++){
          for(let x=0; x<4; x++){
            ctx.strokeStyle = x+y*4<=maxlevel-Math.floor((level-1)/12)*12-1 ? "#ff0" : "#888";
            ctx.fillStyle = x+y*4<=maxlevel-Math.floor((level-1)/12)*12-1 ? "#ffff0040" : "#88888840";
            ctx.fillRect(50+220*x,70+220*y,160,160);
            ctx.strokeRect(50+220*x,70+220*y,160,160);
            if(x+y*4 === vars[0].value-1+(vars[1].value-1)*4){
              ctx.fillRect(50+220*x,70+220*y,160,160);
              ctx.fillRect(50+220*x,70+220*y,160,160);
              ctx.strokeRect(50+220*x-10,70+220*y-10,160+20,160+20);
            }
            ctx.fillStyle = x+y*4<=maxlevel-Math.floor((level-1)/12)*12-1 ? "#ff0" : "#888";
            ctx.fillText((x+y*4+1).toString(16).toUpperCase(),130+220*x,150+220*y);
          }
        }
      }
      else if(graph.type == "explicit"){
        //  陽関数

        //  式の表示
        let p = problems[level];
        let chars,x,y;
        x = 40;
        ctx.strokeStyle = "#ff0";
        ctx.setLineDash([]);
        ctx.lineWidth = 5;
        ctx.textAlign = "left";
        ctx.textBaseline = "center";
        ctx.clearRect(20,20,40,80);
        chars = p.funcstr.match(/\^?./g);
        for(let i=0; i<chars.length; i++){
          if(chars[i].match(/\^/)){
            chars[i] = chars[i].replace("^","");
            y = 50;
            ctx.font = "40px Inconsolata";
          }else{
            y = 60;
            ctx.font = "60px Inconsolata";
          }
          ctx.clearRect(x,20,ctx.measureText(chars[i]).width,80);
          ctx.fillStyle = "#ff0";
          ctx.fillText(chars[i],x,y);
          x += ctx.measureText(chars[i]).width;
        }
        ctx.clearRect(x,20,20,80);
        ctx.strokeRect(20,20,x,80);
        ctx.fillStyle = "#ffff0040";
        ctx.fillRect(20,20,x,80);

        //  グラフ
        //let x,y;  上記のものを使いまわす.

        /*離散的描画法
        for(let i=0; i<920; i+=2){
          x = (i-graph.yaxis)/graph.scale;

          //  ヒント部分
          if(i%30 < 15){
            if(!problems[level].hide){
              y = graph.func(x,problems[level].answer[0],problems[level].answer[1],problems[level].answer[2],problems[level].answer[3]);
              if(0<=-y*graph.scale+graph.xaxis && -y*graph.scale+graph.xaxis<=740){
                ctx.beginPath();
                ctx.arc(x*graph.scale+graph.yaxis,-y*graph.scale+graph.xaxis,2.5,0,Math.PI*2);
                ctx.fill();
              }
            }
            if(problems[level].tangent){
              ctx.fillStyle = "#0ff";
              y = problems[level].funcTangent(x,problems[level].answer[0],problems[level].answer[1],problems[level].answer[2],problems[level].answer[3]);
              if(0<=-y*graph.scale+graph.xaxis && -y*graph.scale+graph.xaxis<=740){
                ctx.beginPath();
                ctx.arc(x*graph.scale+graph.yaxis,-y*graph.scale+graph.xaxis,2.5,0,Math.PI*2);
                ctx.fill();
              }
            }
          }

          //  可動グラフ部分
          y = graph.func(x,vars[0].value,vars[1].value,vars[2].value,vars[3].value);
          ctx.fillStyle = "#ff0";
          if(0<=-y*graph.scale+graph.xaxis && -y*graph.scale+graph.xaxis<=740){
            ctx.beginPath();
            ctx.arc(x*graph.scale+graph.yaxis,-y*graph.scale+graph.xaxis,5,0,Math.PI*2);
            ctx.fill();
          }
        }
        */

        /*折れ線描画法*/
        let seq;
        if(!problems[level].hide){
          //  ヒント部分
          seq = [];
          ctx.strokeStyle = "#ff0";
          ctx.lineWidth = 5;
          ctx.setLineDash([15,15]);
          for(let i=0; i<=920; i++){
            x = (i-graph.yaxis)/graph.scale;
            y = graph.func(x,p.answer[0],p.answer[1],p.answer[2],p.answer[3]);
            //seq.push(-y*graph.scale+graph.xaxis);
            seq.push(y);
          }
          ctx.beginPath();
          ctx.moveTo(0,seq[0]);
          for(let i=1; i<=920; i++){
            y = -seq[i]*graph.scale+graph.xaxis;
            ctx.lineTo(i,y);
          }
          ctx.stroke();
        }
        if(problems[level].tangent){
          //  接線
          seq = [];
          ctx.strokeStyle = "#0ff";
          ctx.lineWidth = 5;
          ctx.setLineDash([15,15]);
          for(let i=0; i<=920; i++){
            x = (i-graph.yaxis)/graph.scale;
            y = p.funcTangent(x,p.answer[0],p.answer[1],p.answer[2],p.answer[3]);
            //seq.push(-y*graph.scale+graph.xaxis);
            seq.push(y);
          }
          ctx.beginPath();
          ctx.moveTo(0,seq[0]);
          for(let i=1; i<=920; i++){
            y = -seq[i]*graph.scale+graph.xaxis;
            ctx.lineTo(i,y);
          }
          ctx.stroke();
        }
        if(problems[level].tangent2){
          //  接線2
          seq = [];
          ctx.strokeStyle = "#0ff";
          ctx.lineWidth = 5;
          ctx.setLineDash([15,15]);
          for(let i=0; i<=920; i++){
            x = (i-graph.yaxis)/graph.scale;
            y = p.funcTangent2(x,p.answer[0],p.answer[1],p.answer[2],p.answer[3]);
            //seq.push(-y*graph.scale+graph.xaxis);
            seq.push(y);
          }
          ctx.beginPath();
          ctx.moveTo(0,seq[0]);
          for(let i=1; i<=920; i++){
            y = -seq[i]*graph.scale+graph.xaxis;
            ctx.lineTo(i,y);
          }
          ctx.stroke();
        }
        if(1){
          //  可動グラフ部分
          //  不連続点の取り扱い!!!
          seq = [];
          ctx.strokeStyle = "#ff0";
          ctx.lineWidth = 10;
          ctx.setLineDash([]);
          for(let i=0; i<=920; i++){
            x = (i-graph.yaxis)/graph.scale;
            y = graph.func(x,vars[0].value,vars[1].value,vars[2].value,vars[3].value);
            //seq.push(-y*graph.scale+graph.xaxis);
            seq.push(y);
          }
          ctx.beginPath();
          ctx.moveTo(0,seq[0]);
          for(let i=1; i<=920; i++){
            y = -seq[i]*graph.scale+graph.xaxis;
            ctx.lineTo(i,y);
          }
          ctx.stroke();
        }

        //  通過する点
        if(problems[level].points){
          ctx.lineWidth = 10;
          ctx.strokeStyle = "#ff0";
          for(let i=0; i<problems[level].points.length; i++){
            x = problems[level].points[i];
            y = graph.func(x,problems[level].answer[0],problems[level].answer[1],problems[level].answer[2],problems[level].answer[3]);
            ctx.beginPath();
            ctx.arc(x*graph.scale+graph.yaxis,-y*graph.scale+graph.xaxis,10,0,Math.PI*2);
            ctx.stroke();
          }
        }
      }

      //  クリアメッセージ
      if(clear){
        let txt = "LEVEL ";
        txt += `${(Math.floor((level-1)/12)+1).toString(16).toUpperCase()}-`;
        txt += `${((level-1)%12+1).toString(16).toUpperCase()}`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "#ffffff40";
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 5;
        ctx.font = "160px Inconsolata";
        ctx.fillText(`${txt}`,460,200);
        ctx.strokeText(`${txt}`,460,200);
        ctx.font = "300px Inconsolata";
        ctx.fillText(`CLEAR!`,460,500);
        ctx.strokeText(`CLEAR!`,460,500);
      }

      ctx.restore();
    }

    function DrawControls(){
      //  スライダー
      ctx.lineWidth = 10;
      ctx.strokeStyle = "#888";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      for(let i=0; i<4; i++){
        ctx.beginPath();
        ctx.moveTo(200,925+i*130);
        ctx.lineTo(200,975+i*130);
        ctx.moveTo(800,925+i*130);
        ctx.lineTo(800,975+i*130);
        ctx.moveTo(200,950+i*130);
        ctx.lineTo(800,950+i*130);
        ctx.stroke();
        //  上限と下限
        ctx.fillStyle = "#000";
        ctx.fillRect(40,910+i*130,100,80);
        ctx.fillRect(860,910+i*130,100,80);
        ctx.fillStyle = "#f00";
        ctx.font = "80px Inconsolata";
        ctx.fillText(vars[i].available ? vars[i].min : "",90,950+i*130,80);
        ctx.fillText(vars[i].available ? vars[i].max : "",910,950+i*130,80);
        //  可動部
        ctx.fillStyle = "#333";
        ctx.beginPath();
        ctx.arc(vars[i].proportion*600+200,950+i*130,30,0,Math.PI*2);
        ctx.fill();
        ctx.fillStyle = vars[i].available ? "#8f8" : "#888";
        ctx.beginPath();
        ctx.arc(vars[i].proportion*600+200,950+i*130,25,0,Math.PI*2);
        ctx.fill();
        ctx.fillStyle = "#333";
        ctx.font = "50px Inconsolata";
        ctx.fillText("abcd"[i],vars[i].proportion*600+200,950+i*130);
      }



      //  ボタン
      ctx.lineWidth = 5;
      ctx.strokeStyle = "#333";
      //  prevボタン
      ctx.fillStyle = buttons.prev.available ? "#8f8" : "#888";
      ctx.fillRect(40,1510,280,100);
      ctx.beginPath();
      ctx.moveTo(40,1610);
      ctx.lineTo(320,1610);
      ctx.lineTo(320,1510);
      ctx.lineTo(40,1510);
      ctx.closePath();
      ctx.stroke();
      //  resetボタン
      ctx.fillStyle = buttons.reset.available ? "#8f8" : "#888";
      ctx.fillRect(40+320,1510,280,100);
      ctx.beginPath();
      ctx.moveTo(40+320,1610);
      ctx.lineTo(320+320,1610);
      ctx.lineTo(320+320,1510);
      ctx.lineTo(40+320,1510);
      ctx.closePath();
      ctx.stroke();
      //  nextボタン
      ctx.fillStyle = buttons.next.available ? "#8f8" : "#888";
      ctx.fillRect(40+640,1510,280,100);
      ctx.beginPath();
      ctx.moveTo(40+640,1610);
      ctx.lineTo(320+640,1610);
      ctx.lineTo(320+640,1510);
      ctx.lineTo(40+640,1510);
      ctx.closePath();
      ctx.stroke();
      //  各ボタンの表示部
      ctx.fillStyle = "#333";
      ctx.font = "100px Inconsolata";
      ctx.fillText("PREV",180,1560);
      ctx.fillText("RESET",180+320,1560);
      ctx.fillText("NEXT",180+640,1560);
    }

    //  (x,y)が矩形内にあるかどうか
    function IsIn(x,y,x0,y0,w,h){
      let bool = 1;
      bool = bool && x0 < x;
      bool = bool && x < x0+w;
      bool = bool && y0 < y;
      bool = bool && y < y0+h;
      return bool;
    }











  </script>
</html>
